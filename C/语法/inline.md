[toc]
# 1. 背景
## 1.1 为什么出现inline
之前我们在学习宏的展开的时候提到宏展开有很多隐含的问题。但是有些时候我们有希望编译的时候就能展开部分代码，这样在运行的时候能提高不少堆栈切换的开销。在这样的背景下产生inline机制。可以简单理解为编译的时候就进行函数展开，同时支持语法检查。
## 1.2 注意
* inline只影响代码translation unit（可以理解为源码文件）的编译行为。
    * 因此，inline不能作为函数声明（Declare）使用，编译会报错。只能作用在函数定义中（Definition）

* inline只是建议编译器进行内联展开处理，并不是强制要求。如果编译时设-O0，即使是inline函数也不会被内联展开，除非设置了强制内联（__attribute__((always_inline))）属性。
# 2. 使用
```
foo.c:
/* 这里定义了一个inline的函数foo() */
inline foo() {
    ...;   <- 编译器会像非inline函数一样为foo()生成独立的汇编码
}
void func1() {
    foo(); <- 同文件内foo()可能被编译器内联展开编译而不是直接call上面生成的汇编码
}
而在另一个文件里调用foo()的时候，则直接call的是上面文件内生成的汇编码：
bar.c:
extern foo(); <- 声明foo()，注意不能在声明内带inline关键字
void func2() {
    foo();    <- 这里就是直接call在foo.c内为foo()函数生成的汇编码了
}
```
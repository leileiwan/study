
# 1. 背景
* 进程、文件系统、内存之间的操作都离不开缓冲区，理解缓冲区真正作用对理解操作系统非常重要。

# 2. 缓冲区作用
缓冲区作用体现在两方面
* 操作系统和各种设备解耦：设备挂载和操作系统设计都更加灵活
* 对设备文件操作运行效率更高


按理来说，设备和内存之间添加一个缓冲区，只会提高复制缓冲区开销，不可能提高效率的。快的原因是缓冲区的共享。
* 多个进程操作同一个文件共享，提高效率。
* 一段时间，一个进程多次操作一个文件共享。（概率是非常高的）

因此缓冲区的设计是围绕如何保证数据交互的正确性和如何让数据停留在缓冲区中竟可能长来设计的。


# 3. 缓冲区的总体结构图
![2019-09-02-09-18-17.png](./images/2019-09-02-09-18-17.png)
* 缓冲区中有两个非常重要的结构
    * buffer_head:负责进程和缓冲区数据交互，确保数据交互正确的前提下，让数据在缓冲区中停留更长时间。
    * request主要负责缓冲区和设备数据交互，确保正确交互前提下，及时的将设备数据同步到缓冲区中

![2019-09-02-09-24-53.png](./images/2019-09-02-09-24-53.png)
下面主要内容是讲解上面两个结构体。

# 4. b_dev、b_blocknr、request作用
b_dev、b_blocknr两个字段是buffer_head结构中非常重要的两个字段，是缓冲区支持多进程文件基础。
* 确定正确性和经过能让缓冲区停留在内存基础。

## 4.1 保证数据进程和缓冲区交互正确性（设备号和块号关键）
* 进程和缓冲区交互不是以文件为单位，而是块为单位。一次交互不足一个块，任然占用一个缓冲块。

### 4.1.1 b_dev、b_blocknr（进程到缓冲区）
* 缓冲区块大小和硬盘块大小一致。保证数据交互正确性，首先是磁盘数据块和缓冲区中数据块严格对应。
* 因为磁盘设备号和块号能唯一确定一个磁盘块。同时每一个缓冲区块都有一个buffer_head管理。内核通过缓冲区块buffer_blocknr和b_dev两个字段，把缓冲区和硬盘数据块绑定。确保数据交互的唯一性。

![2019-09-02-09-51-30.png](./images/2019-09-02-09-51-30.png)

文件读写都是通过设备号和块号到缓冲区为止。
![2019-09-02-10-10-49.png](./images/2019-09-02-10-10-49.png)
![2019-09-02-10-11-07.png](./images/2019-09-02-10-11-07.png)

### 4.1.2 request作用
内核通过request结构保证硬盘和缓冲区之间的数据交互。
![2019-09-02-11-21-38.png](./images/2019-09-02-11-21-38.png)
![2019-09-02-11-24-11.png](./images/2019-09-02-11-24-11.png)
![2019-09-02-11-26-51.png](./images/2019-09-02-11-26-51.png)
![2019-09-02-11-27-04.png](./images/2019-09-02-11-27-04.png)

request 字段本质上还是主要靠设备号和块号来实现和和磁盘的交互。

## 4.2 让数据在缓冲区中停留竟可能长的时间
b_dev和blocknr不仅是保证数据正确性的基础，也是尽可能让数据保存在缓冲区中的基础。

数据停留在缓冲区的标志是缓冲区块和设备块是否还存在绑定关系。

### 4.2.1 在缓冲区中寻找设备号和块号对应的项
![2019-09-02-11-45-14.png](./images/2019-09-02-11-45-14.png)
![2019-09-02-11-45-28.png](./images/2019-09-02-11-45-28.png)
* 很显然更，设备号和块号使用的是散列hash
* 如果在缓冲中读取到，就节省了两个数量级的时间。
* 如果缓冲区中寻找了一遍，缓冲区块中都和已有的设备绑定关系。实在找不到，就只能找一个暂时没有进程使用。就只能找一个暂时没有进程使用(b_count=0)的空闲块，废除已经存在的绑定关系，用新的绑定关系取代。
![2019-09-02-11-52-46.png](./images/2019-09-02-11-52-46.png)
上面代码意思是申请一个缓冲区块和已有数据建立绑定关系。申请缓冲区块存在两种情况:
* 一种是系统刚运行，有空闲的缓冲区块申请
* 一种是运行很长时间，没有空闲的缓冲区申请，只能废除原有缓冲区和数据块关系。

* 内核中没有任何代码主动解绑缓冲区块和磁盘数据块关系的代码，只有通过b_dev、blocknr申请不到缓冲区块才进行解绑。

## 4.3 request设计思路
request设计思路和缓冲区正好相反，尽可能快让缓冲块和硬盘进行数据交互。

* request也有b_dev、和b_blocknr类似字段，就是设备号dev和首扇区号sector。他们除了保证缓冲区块和硬盘数据交互的正确性外，更多的是尽快的让缓冲区块和数据块交互。

* 下面代码是将设备添加到request请求队列中，插入到期请求队列存在两种情况
    * 一种是硬盘是空闲的，让硬盘处理当前请求
    * 一种是硬盘非空闲，就把这些请求插入到请求队列中。

![2019-09-02-14-09-23.png](./images/2019-09-02-14-09-23.png)
![2019-09-02-14-09-36.png](./images/2019-09-02-14-09-36.png)
![2019-09-02-14-09-50.png](./images/2019-09-02-14-09-50.png)
![2019-09-02-14-10-04.png](./images/2019-09-02-14-10-04.png)

* 下面是针对请求队列的读写操作。无论是读操作还是写操作，最后都需要调用end_request()和do_hd_quest()函数。这样就形成了处理请求项队列中的请求项的循环操作。
    * do_hd_quest()中的INIT_REQUEST这个宏用于判断循环是否结束。如果当前请求项不为空，标识队列中还有请求项对应的缓冲区块需要交互，就继续下达交互命令。直到把所有请求项队列中的任务都执行完。
![2019-09-02-14-17-56.png](./images/2019-09-02-14-17-56.png)
![2019-09-02-14-18-11.png](./images/2019-09-02-14-18-11.png)
![2019-09-02-14-18-24.png](./images/2019-09-02-14-18-24.png)
![2019-09-02-14-18-38.png](./images/2019-09-02-14-18-38.png)

* request项是32，也就是request[32],为什么要设置32个request项，而不是64或者16呢。
    * 内存和磁盘读写速度差2个两级。缓冲区块最多是3000多块，对应request项也就是32项左右
    * 如果request项太多，磁盘来不及处理，request项会闲置，浪费request占用内存
    * request项太少，由于没有足够的请求项，导致新的读写任务无法下达，硬盘空闲，进程无合适的缓冲区块可用，被频繁挂起，导致系统效率降低。


# 5. uptodate和dirt作用
* b_dev和blocknr两个字段是进程能共享缓冲区块的基础，是缓冲区块数据是否任然停留的标志。停留就是要被共享。

* 共享分两个方向
    * 一个是进程方向，进程能共享那些缓冲区，不能共享那些。
    * 一个是硬盘方向，那些需要同步到硬盘上，那些不需要同步。
    * 这两个方向的核心任务是确保缓冲块和数据块数据的正确性。

* buffer_head中的b_uptodate和b_dirt两个字段都是为了解决缓冲区块和数据块正确性存在的
    * b_uptodate针对进程方向，他告诉内核，只要b_uptodate被设置为1，缓冲区块的数据已经是数据块中最新的数据。可以方向的共享数据。反之，告诉内核缓冲区块并没有用绑定的数据块中的数据更新，不支持进程共享数据块。
    * b_dirt是针对磁盘方向，只要缓冲区块b_dirt字段被设置成1，就是告诉内核，这个缓冲区块中的内容已经被进程方向的数据改写了，需要最终同步到磁盘上。反之不需要同步。

## 5.1 b_uptodate的作用
* 假设我们没有b_uptodate字段
    * 进程读数据:假设磁盘申请了一个缓冲区块（申请缓冲区块和同步数据到磁盘是异步的），此时进程读取该缓冲区数据很有可能是垃圾数据。
    * 写数据：如果写入缓冲区块中的数据小于一个块，缓冲区残留着垃圾数据。当同步缓冲区数据到磁盘中时，就是同步的垃圾数据。

* 为此，在磁盘中断服务程序执行时，在数据从磁盘读入缓冲区后或者缓冲区数据同步到磁盘后，都会将b_uptodate字段设置为1.
![2019-09-02-15-15-42.png](./images/2019-09-02-15-15-42.png)
![2019-09-02-15-15-54.png](./images/2019-09-02-15-15-54.png)

* 值得注意的是，b_uptodate被设置成1，就是告诉内核，缓冲区块中数据已经用数据块中的内容更新了。但是并不代表缓冲区数据和磁盘中数据一致（磁盘中可能存在脏数据）。比如，新建一个文件，清除缓冲区数据后就设置b_uptodate被设置成1，没有同步数据到磁盘操作，因此数据不一致。但是这不影响数据的正确同步。

![2019-09-02-15-31-13.png](./images/2019-09-02-15-31-13.png)
![2019-09-02-15-31-25.png](./images/2019-09-02-15-31-25.png)

* 如果b_uptodate为0，内核会阻拦进程，不让进程共享缓冲区数据。不论读写。
![2019-09-02-15-55-20.png](./images/2019-09-02-15-55-20.png)

## 5.2 b_dirt作用
进程往缓冲区中写数据后，就要将b_dirt设置为1.    
![2019-09-02-16-02-36.png](./images/2019-09-02-16-02-36.png)
![2019-09-02-16-02-48.png](./images/2019-09-02-16-02-48.png)
![2019-09-02-16-03-00.png](./images/2019-09-02-16-03-00.png)


## 5.3 读写操作在request占用空间设置
相比写操作，读操作对用户进程更加紧迫。因此请求项对这两种操作设定了不同的大小空间。
![2019-09-02-16-09-34.png](./images/2019-09-02-16-09-34.png)
* 请求项中只有2/3空间用来写操作，而全部空间用来读操作。因此，在同等条件下，读操作机会更多。


## 5.4 i_uptodate、i_dirt、s_dirt作用
* b_uptodate,b_dirt保证缓冲区与硬盘数据正确性
* 文件管理信息中也有类似字段
    * 比如inode_table[32]也有类似字段，比如i_uptodate(没有实际使用)和i_dirt。
        * i_dirt比较容易理解。当改变文件大小后，inode_table信息会发生变化，和磁盘数据不一致。因此i_dirt用来同步i_dirt和inode_table[32]

    ![2019-09-02-16-21-18.png](./images/2019-09-02-16-21-18.png)
    ![2019-09-02-16-21-32.png](./images/2019-09-02-16-21-32.png)

    * super_block[8] 不存在是否空闲的问题.因此不需要count这样字段来记录超级快的引用次数。
    ![2019-09-02-16-31-53.png](./images/2019-09-02-16-31-53.png)

    * 除了i节点和超级块外，还有i节点位图和逻辑块位图。
    ![2019-09-02-16-33-34.png](./images/2019-09-02-16-33-34.png)
    ![2019-09-02-16-33-46.png](./images/2019-09-02-16-33-46.png)
    ![2019-09-02-16-33-59.png](./images/2019-09-02-16-33-59.png)
    从以上代码中可以看出, i 节点位图、超级块位图载入缓冲块后,这些缓冲块的 b_count被设置为1 ,之后并没有将其释放过,这样这些缓冲块的引用计数就无法还原为 0 了。所以任何进程申请新缓冲块的时候,都无能申请到它们,所以这些缓冲块成为专用。

## 5.5 b_lock和*b_wait作用
* b_lock:当缓冲区正在和数据块同步时，内核会拦截进程对缓冲区操作。因此可以把b_lock设置为1.当同步完成后，设置为0，进程就可以操作缓冲区了。
* 当b_lock设置为1，所有进程操作该缓冲区都会被挂起。这时需要记录那些进程因为等待这个缓冲区块而被挂起，因为这时一个进程对待队列数据结构，可以通过*b_wait字段解决问题。

### 5.5.1 初始化缓冲区块
怠速进程初始化缓冲区块时，b_block全部设成0，*b_wait全部设成NULL。
![2019-09-02-17-04-18.png](./images/2019-09-02-17-04-18.png)

### 5.1.2 缓冲区申请后设置b_lock为1
缓冲块被申请后,开始底层块操作前,就要先把该块加锁,即把 b_lock 设置为 l ,然后进行底层操作。
![2019-09-02-17-05-40.png](./images/2019-09-02-17-05-40.png)
![2019-09-02-17-06-14.png](./images/2019-09-02-17-06-14.png)

缓冲块 与 硬盘数据块开始交互数据时, lock_buffer()函数先判断缓冲块是否加锁。如果加锁了(很有可能该缓冲块早就被别的进程申请了,现在正 与 硬盘交 互数据),就直接调用 sleep_on()函数将进程挂起,井切换到其他进程去执行。 等到将来切换回 当 前进程后,再将缓 冲块继续加锁。如果没加锁,就将其加锁,以防其他进程i吴操作。
    



<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 安装文件系统](#2-安装文件系统)
    - [2.1 获取外设超级块](#21-获取外设超级块)
    - [2.2 确定根文件系统挂载点](#22-确定根文件系统挂载点)
    - [2.3 超级块和根文件系统挂接](#23-超级块和根文件系统挂接)
- [3. 实例1--用户打开一个在硬盘中已经存在的文件，并读取文件内容](#3-实例1--用户打开一个在硬盘中已经存在的文件并读取文件内容)
    - [3.1 打开文件](#31-打开文件)
        - [3.1.1 filp[20],file_table[64],i节点三者之间关系](#311-filp20file_table64i节点三者之间关系)
    - [3.2 filp[20]file_table[64]挂接](#32-filp20file_table64挂接)
    - [3.3 获取文件i节点](#33-获取文件i节点)
        - [3.3.1 获取目录文件i节点](#331-获取目录文件i节点)
            - [3.3.1.1 进入open_namei()](#3311-进入open_namei)
            - [3.3.1.2 open_namei()->dir_namei()](#3312-open_namei-dir_namei)
            - [3.3.1.3 open_name()->dir_namei()->get_dir()](#3313-open_name-dir_namei-get_dir)
            - [3.3.1.4 open_name()->dir_namei()->get_dir()->find_entry()](#3314-open_name-dir_namei-get_dir-find_entry)
            - [3.3.1.5 open_name->dir_namei()->get_dir()->iget()](#3315-open_name-dir_namei-get_dir-iget)
        - [3.3.2 获取目标文件i节点](#332-获取目标文件i节点)
        - [3.3.3 将i节点与file_table[64]挂接](#333-将i节点与file_table64挂接)
    - [3.4 读文件](#34-读文件)
        - [3.4.1  确定数据块在外设中位置](#341--确定数据块在外设中位置)
            - [3.4.1.1 file_read()->bmap()](#3411-file_read-bmap)
            - [3.4.1.2 i节点是如何管理文件的](#3412-i节点是如何管理文件的)
        - [3.4.2 将数据块读入缓冲块 file_read()->bread()](#342-将数据块读入缓冲块-file_read-bread)
        - [3.4.3 将缓冲区块中的文件复制到进程空间](#343-将缓冲区块中的文件复制到进程空间)
    - [3.5 写文件](#35-写文件)
        - [3.5.1 确定文件写入位置](#351-确定文件写入位置)
            - [3.5.1.1 sys_write()](#3511-sys_write)
            - [2.5.1.2 sys_write->file_write()](#2512-sys_write-file_write)
            - [2.5.1.3 sys_write()->file_write()->create_block()](#2513-sys_write-file_write-create_block)
        - [3.5.2 申请缓冲区块](#352-申请缓冲区块)
        - [3.5.3 将指定数据从进程空间复制到缓冲区块](#353-将指定数据从进程空间复制到缓冲区块)
        - [3.5.4 同步缓冲区中数据到缓存](#354-同步缓冲区中数据到缓存)
            - [3.5.4.1 update定期同步](#3541-update定期同步)
            - [3.5.4.2 缓冲区使用到极限，操作系统强行同步](#3542-缓冲区使用到极限操作系统强行同步)
    - [3.6 修改文件](#36-修改文件)
        - [3.6.1 进程重定位文件当前操作指针](#361-进程重定位文件当前操作指针)
    - [3.7 关闭文件](#37-关闭文件)
        - [3.7.1 filp[20]和file_table[64]解除关系](#371-filp20和file_table64解除关系)
        - [3.7.2 文件i节点释放](#372-文件i节点释放)
    - [3.8 删除文件](#38-删除文件)
        - [3.8.1 对文件删除进行检查](#381-对文件删除进行检查)
        - [3.8.2 进行具体删除操作](#382-进行具体删除操作)
- [4. 小节](#4-小节)

<!-- /TOC -->
# 1. 背景
文件系统概念和操作。

# 2. 安装文件系统
* 操作系统加载了根文件系统，使操作系统能够以文件形式和根设备交互。
* 安装磁盘文件系统，就是将磁盘文件系统挂在根设备文件系统上。

安装文件系统分一下三步:
* 将磁盘中超级快读出来，并载入super_block[8]中
* 将虚拟盘指定i节点读出，并将此节点加载在系统中的inode_table[32]中
* 将系统中超级块挂接到inode_table[32]中指定的i节点上

我们常使用挂在文件系统命令是"mount /dev/hd1 /mnt"，意思试讲/dev/hd1设备挂在在/mnt目录下。
* 系统会启动mount()进程，并最终执行sys_mount()系统调用
* 磁盘是可以分区的，一个分区就是一个设备。这里我们将整个设备作为一个分区，具体后面讲述。

![2019-08-21-09-44-47.png](./images/2019-08-21-09-44-47.png)
![2019-08-21-09-45-25.png](./images/2019-08-21-09-45-25.png)

## 2.1 获取外设超级块
read_super()读取设备数据主要分为下面三步:
* super_block中选定一个空闲项来存储超级块
* 将超级块载入上面空闲项
* 根据超级块提供的的信息，载入i节点位图和逻辑块位图

加载超级快表项时需要加锁。
![2019-08-21-11-33-52.png](./images/2019-08-21-11-33-52.png)
![2019-08-21-11-34-17.png](./images/2019-08-21-11-34-17.png)
![2019-08-21-11-34-31.png](./images/2019-08-21-11-34-31.png)

## 2.2 确定根文件系统挂载点
再次调用namei()函数，根据/mnt路径名，获取mnt目录文件的i节点后，分析i节点属性，判断i节点是否可以用来挂载文件系统。

代码分析见上面

## 2.3 超级块和根文件系统挂接
挂接前确保挂接点和被挂接点都是“干净的”
    * hdl设备的文件系统没有被安装过
    * mnt 目录文件上也没有安装其它文件系统
![2019-08-21-13-41-40.png](./images/2019-08-21-13-41-40.png)

# 3. 实例1--用户打开一个在硬盘中已经存在的文件，并读取文件内容
主要分为两部分，打开文件和读文件
![2019-08-21-13-45-02.png](./images/2019-08-21-13-45-02.png)

## 3.1 打开文件
打开进程本质是某个进程操作文件，需要如下两步:
* 将用户进程中的task_struct中的filp[20]和内核中的file_table[64]进行登记
* 用户需要打开的i节点在file_table[64]进行登记

### 3.1.1 filp[20],file_table[64],i节点三者之间关系
* filp[20]记录进程打开的文件数，一个进程可以打开多个文件，也可以打开同一文件多次。没打开一次，filp[20]就记录一项，因此一个进程最多能同时打开文件20次

* file_table[64]是记录所有进程打开文件的数据结构，和filp[20]一样也是记录打开文件次数。系统最多能同时打开文件次数64次。

* i节点是记录文件属性最关键结构，操作系统中i节点和文件是一一对应的，找到i节点就能找到唯一文件。内核通过inode_table[32]掌握正在使用的文件i节点数，每个被使用的i节点都要记录其中。

打开文件其实就是建立三者数据结构之间关系。open()函数映射到sys_open()系统调用实现上面关系建立。
![2019-08-21-14-06-35.png](./images/2019-08-21-14-06-35.png)

## 3.2 filp[20]file_table[64]挂接

sys_open()中实现挂接。
![2019-08-21-14-14-46.png](./images/2019-08-21-14-14-46.png)
![2019-08-21-14-15-01.png](./images/2019-08-21-14-15-01.png)

## 3.3 获取文件i节点

主要根据文件路径名找到文件i节点。
这次找i节点和前面找i节点过程不一致，因为这次文件是存储在硬盘中。查找过程如下：
寻找i节点->通过i节点找到目录文件->
通过目录文件找到目录项->通过目录项找到目录文件i节点号->
通过目录文件找到目录项->通过目录项找到目录文件i节点号->
...
循环下去，最终找到hello.txt文件
![2019-08-21-14-24-59.png](./images/2019-08-21-14-24-59.png)

### 3.3.1 获取目录文件i节点
#### 3.3.1.1 进入open_namei()
* 进入open_namei()函数后，先对用户所要打开文件设置参数mode、flag，执行代码如下。
![2019-08-23-08-59-57.png](./images/2019-08-23-08-59-57.png)
![2019-08-23-09-00-12.png](./images/2019-08-23-09-00-12.png)
![2019-08-23-09-10-07.png](./images/2019-08-23-09-10-07.png)
![2019-08-23-09-10-25.png](./images/2019-08-23-09-10-25.png)
![2019-08-23-09-10-46.png](./images/2019-08-23-09-10-46.png)

* dir_namei()函数分析用户给出路径，获取最后一个目录文件的i节点（树梢i节点）

#### 3.3.1.2 open_namei()->dir_namei()
* 上面get_dir()函数主要是为了获取树梢i节点
* 下面的通过指向路径的字符串指针，获取文件名和文件名长度
![2019-08-23-09-18-36.png](./images/2019-08-23-09-18-36.png)

#### 3.3.1.3 open_name()->dir_namei()->get_dir()
get_dir()函数之前描述过，原理是不断通过i节点找到目录项，再通过目录项获取i节点过程。
* find_entry()获取目录项
* iget() 通过目录项获取i节点
![2019-08-23-09-51-32.png](./images/2019-08-23-09-51-32.png)
![2019-08-23-09-51-52.png](./images/2019-08-23-09-51-52.png)
![2019-08-23-09-52-20.png](./images/2019-08-23-09-52-20.png)

#### 3.3.1.4 open_name()->dir_namei()->get_dir()->find_entry()
find_entry()首先通过目录文件i节点确定目录文件中有多少个i节点，确定目录文件中有多少个目录项，之后从目录文件第一个逻辑块开始，不断将该文件逻辑块内容读到缓冲区，并从中查找指定的目录项，直到找到为止。

![2019-08-23-11-27-08.png](./images/2019-08-23-11-27-08.png)
![2019-08-23-11-27-25.png](./images/2019-08-23-11-27-25.png)
![2019-08-23-11-27-47.png](./images/2019-08-23-11-27-47.png)
![2019-08-23-11-27-58.png](./images/2019-08-23-11-27-58.png)

#### 3.3.1.5 open_name->dir_namei()->get_dir()->iget()
iget函数是根据目录项中提供的i节点号和设备块号来获取i节点。
* 现在inode_table[32]寻找是否有i节点，如果有就直接使用,如果找不到就加载。
* 如果发现i节点已经装上文件系统，将该文件系统根i节点载入，这个根i节点就成为在另一个文件系统查找起点。

下面代码是获取mnt的i节点（挂载的文件系统）
![2019-08-23-11-46-06.png](./images/2019-08-23-11-46-06.png)
![2019-08-23-11-46-19.png](./images/2019-08-23-11-46-19.png)

通过read_inode()函数，从外设上（硬盘）读取i节点，载入inode_table[32]中。
![2019-08-23-11-49-01.png](./images/2019-08-23-11-49-01.png)
获取磁盘文件系统根i节点后，get_dir()将不断调用find_entry()函数，iget()函数，最终到到树梢i节点。
最终函数返回到open_namei()，获取树梢i节点和文件名及长度。

### 3.3.2 获取目标文件i节点
获取文件i节点和之前获取目录文件方式基本一致，也是调用find_entry()和iget()获取目录文件i节点。
![2019-08-23-13-43-22.png](./images/2019-08-23-13-43-22.png)
![2019-08-23-13-43-35.png](./images/2019-08-23-13-43-35.png)
![2019-08-23-13-43-48.png](./images/2019-08-23-13-43-48.png)

这里已经获取到目标文件i节点，下面将i节点和目标file_table[64]挂接

### 3.3.3 将i节点与file_table[64]挂接
* 现在我们已经将目标文件i节点已经载入到inode_table[32]中，现在要将indoe[32]和file_table[64]挂接。
* 此外，操作系统还对文件的属性、引用计数、读写指针偏移进行设置。
![2019-08-23-13-54-23.png](./images/2019-08-23-13-54-23.png)

到此，file_table[64]一边和filp[32]进行绑定，一边和indoe_table[32]绑定。
建立绑定关系后，操作系统把fd返回给用户进程，fd是file_table[64]偏移量，即文件句柄。

至此，打开文件结束。

## 3.4 读文件
由read完成读文件操作。read()函数映射到sys_read()中执行，在执行文件之前，先对操作可行性进行检查，包括用户传进来的文件句柄，读取文件大小，和用户进程是否有足够空间写入。如果检查都通过，再执行file_read()主体函数。
```
int size= read ( fd , buffer , sizeof(buffer ))；
```

### 3.4.1  确定数据块在外设中位置
![2019-08-23-14-38-45.png](./images/2019-08-23-14-38-45.png)
#### 3.4.1.1 file_read()->bmap()
file_read()通过调用dmap()函数来确定指定文件数据在块设备上的逻辑块号。执行代码如下：
![2019-08-23-14-45-35.png](./images/2019-08-23-14-45-35.png)

bmap()函数会调用_bmap()函数，其中增加了一个参数。
![2019-08-23-14-47-55.png](./images/2019-08-23-14-47-55.png)

#### 3.4.1.2 i节点是如何管理文件的
i节点是通过i_zone结构体来管理数据块文件。
![2019-08-23-14-51-21.png](./images/2019-08-23-14-51-21.png)
![2019-08-23-14-52-59.png](./images/2019-08-23-14-52-59.png)
* 块数分为3种类型，7块，7+512,7+512+512*512，三种类型等级（1块是1K）
![2019-08-23-15-03-49.png](./images/2019-08-23-15-03-49.png)
![2019-08-23-15-04-11.png](./images/2019-08-23-15-04-11.png)
![2019-08-23-15-04-30.png](./images/2019-08-23-15-04-30.png)
![2019-08-23-15-04-42.png](./images/2019-08-23-15-04-42.png)

### 3.4.2 将数据块读入缓冲块 file_read()->bread()
将数据块读入缓冲区块。
调用bread()函数将硬盘中文件的第一个块读入到缓冲区。bread()详细执行过程之前已经介绍过。
![2019-08-23-15-09-33.png](./images/2019-08-23-15-09-33.png)

### 3.4.3 将缓冲区块中的文件复制到进程空间
数据载入缓冲区后，系统要将其从缓冲区复制到指定的进程空间数据区内（*buf）
![2019-08-23-15-19-23.png](./images/2019-08-23-15-19-23.png)


## 3.5 写文件
* 进程将数据先写入缓冲区，操作系统在适当条件下将缓冲区内容同步在外设中。
* 操作系统只以数据块为单位（1k）将缓冲区块内容同步在外设上
* 在同步之前，缓冲区块与外设同步的数据块要一一绑定，确定外设上写入位置，以保证用户空间写入缓冲区的数据能准确的同步到指定的逻辑块中

### 3.5.1 确定文件写入位置
write()函数最终映射到sys_write()函数中去，该函数先对参数进行合法性检查，之后调用file_write()写入文件。

#### 3.5.1.1 sys_write()
![2019-08-26-09-20-20.png](./images/2019-08-26-09-20-20.png)
![2019-08-26-09-20-33.png](./images/2019-08-26-09-20-33.png)
#### 2.5.1.2 sys_write->file_write()
* 先检查f_flag标志来确定写入位置，然后调用create_block创建一个与该文件对应的外设逻辑块，并返回逻辑块号
![2019-08-26-09-31-40.png](./images/2019-08-26-09-31-40.png)
#### 2.5.1.3 sys_write()->file_write()->create_block()
* 创建一个新的数据块，并使之与i节点指定i_zone[9]对应。
![2019-08-26-09-38-29.png](./images/2019-08-26-09-38-29.png)
![2019-08-26-09-41-54.png](./images/2019-08-26-09-41-54.png)
![2019-08-26-09-42-13.png](./images/2019-08-26-09-42-13.png)

* 具体创建工作实在new_block()函数中执行
    * 新建数据块逻辑块置1
    * 缓冲区中为新建数据块申请缓冲区块，用于承载写入内容
    ![2019-08-26-09-48-50.png](./images/2019-08-26-09-48-50.png)

### 3.5.2 申请缓冲区块
new_block()创建的是新缓冲区块，所以无需从外设上载入逻辑块。
![2019-08-26-09-52-18.png](./images/2019-08-26-09-52-18.png)
![2019-08-26-09-52-34.png](./images/2019-08-26-09-52-34.png)
### 3.5.3 将指定数据从进程空间复制到缓冲区块
![2019-08-26-10-01-50.png](./images/2019-08-26-10-01-50.png)

### 3.5.4 同步缓冲区中数据到缓存
同步缓冲区数据到硬盘两种方法
    * 一个update定期同步
    * 一个因为缓冲区使用到极限，操作系统强行同步
#### 3.5.4.1 update定期同步
* 之前讲述shell进程，启动了一个update进程，这个进程常驻与内存，功能是将缓冲区内容同步到外设上。该进程会调用pause()函数，将函数设置成可中断状态，每个一段时间，操作系统会唤醒update进程唤醒，并将缓冲区数据同步到外设上。

* sync()最终映射到sys_sync()系统调用函数去执行。为了保证文件内容同步完整性，需要将文件i节点位图，文件i节点，文件数据块，文件数据块对应的逻辑位图全部同步到外设上。
* sys_sync()函数先将改动过的文件i节点写入缓冲区（其余内容已经在缓冲区中）。之后遍历整个缓冲区，只要发现缓冲区中内容被改过（b_dirt置1），就将全部同步到外设上
![2019-08-26-10-16-27.png](./images/2019-08-26-10-16-27.png)

同步i节点任务是由sys_inode()函数完成
![2019-08-26-10-24-41.png](./images/2019-08-26-10-24-41.png)
![2019-08-26-10-30-53.png](./images/2019-08-26-10-30-53.png)
![2019-08-26-10-31-06.png](./images/2019-08-26-10-31-06.png)

同步完成后，update进程将被挂起，下一个进程被唤醒后，继续同步到缓冲区。

#### 3.5.4.2 缓冲区使用到极限，操作系统强行同步
当持续吸入很多数据时，可能update进程还没来得及同步，缓冲区就已经写满，这时需要强行同步缓冲区中数据到磁盘中。

* 此任务是由getblk()完成的
![2019-08-26-10-51-57.png](./images/2019-08-26-10-51-57.png)
![2019-08-26-10-52-15.png](./images/2019-08-26-10-52-15.png)
![2019-08-26-10-52-28.png](./images/2019-08-26-10-52-28.png)

## 3.6 修改文件
* 修改文件本质是在原有文件任意位置插入、删除数据。是sys_read()、sys_write()、sys_lseek()几个函数组合使用

### 3.6.1 进程重定位文件当前操作指针
进程调用lseek()函数将文件当前操作f_pos进行重新定位，最终映射到sys_lseek()函数去执行。
![2019-08-26-11-04-25.png](./images/2019-08-26-11-04-25.png)


## 3.7 关闭文件
close()函数完成关闭文件，映射到sys_close()系统调用中执行.

### 3.7.1 filp[20]和file_table[64]解除关系
![2019-08-26-11-20-40.png](./images/2019-08-26-11-20-40.png)

### 3.7.2 文件i节点释放
* 文件i节点被释放过程如下:
    * 先对i节点各类属性进行检查，如果i节点发生变化，将i节点同步到指定缓冲区块中
    * 递减i节点i_count,使i节点计数为0，这个i节点在inode-table[32]编程空闲项


![2019-08-26-11-30-00.png](./images/2019-08-26-11-30-00.png)
![2019-08-26-11-30-14.png](./images/2019-08-26-11-30-14.png)

## 3.8 删除文件
* 关闭文件只是解除filp和file_table之间关系
* 删除文件是删除磁盘中对应文件

linx 0.11中允许sys_link利用系统函数sys_link将/mnt/usr/zhang/lei.c 路径名指向/mnt/user/hello.txt的文件。i节点中利用i_links字段标识有多少个路径名（目录项）链接到一个文件。每建立一个文件链接,i_nlinks就+1.

### 3.8.1 对文件删除进行检查
unlink()函数最终映射到sys_unlink()系统调用中执行，先获取hello.txt文件i节点，之后检查i节点属性，当前进程对文件的操作权限信息，确定是否有权限删除删除该文件。

![2019-08-26-11-48-31.png](./images/2019-08-26-11-48-31.png)
![2019-08-26-11-48-45.png](./images/2019-08-26-11-48-45.png)
![2019-08-26-11-49-02.png](./images/2019-08-26-11-49-02.png)

### 3.8.2 进行具体删除操作
![2019-08-26-11-53-40.png](./images/2019-08-26-11-53-40.png)
![2019-08-26-11-53-50.png](./images/2019-08-26-11-53-50.png)

iput（）函数中执行情景如下，和之前有点区别
![2019-08-26-11-54-38.png](./images/2019-08-26-11-54-38.png)

* 调用 truncate()函数,根据文件 i 节点中 i_zone[9 ]释放文件在外设上的所有逻辑块。
![2019-08-26-11-55-10.png](./images/2019-08-26-11-55-10.png)
![2019-08-26-11-55-22.png](./images/2019-08-26-11-55-22.png)

* 调用 freeinode( )函数,清空 i 节点位图和 i 节点表项。
![2019-08-26-11-55-59.png](./images/2019-08-26-11-55-59.png)

操作系统将被清空的 i 节点位图、逻辑块位图、 1 节点表项信息,同步到硬盘上(并未清除对应的逻辑块中的内容)。它们都是 hello.txt 文件的管理信息,这些信息不存在了,即便该
文件的逻辑块内容还存储在硬盘上,也无桂再访问到该文件。

# 4. 小节
操作系统对文件的一切操作,都可以分为两个方面:对 super_block 、 d_super_block 、
m_inode 、 d in ode 、 i 节点位图、逻辑块位图这类文件管理信息的操作以及对文件数据内容的
操作。新建、打开、关闭、删除文件属于对文件管理信息的操作。读文件、写文件和修改文
件则主要是操作文件数据内容。

操作文件管理信息就是建立或解除进程与文件的关系链条,链条的主干为 task struct 中
的吨lp[20 ]一-file_table[64]一一inode _ table[32 ]。进程就可以沿着关系链条,依托缓冲区与
硬盘进行数据交互。当关系链条解除后,进程则不再具备操作指定文件的能力。如果文件管
理信息被更改,贝 IJ 操作系统要将此更改落实在硬盘上,以免失去对文件数据内容的控制。

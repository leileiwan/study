<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 管道机制](#2-管道机制)
    - [2.1 管道的创建过程](#21-管道的创建过程)
        - [2.1.1 为管道文件在file_table[64]中申请空闲项](#211-为管道文件在file_table64中申请空闲项)
        - [2.1.2 进程中task_struct的filp[20]和file_table[64]挂接](#212-进程中task_struct的filp20和file_table64挂接)
        - [2.1.3 创建管道文件i节点](#213-创建管道文件i节点)
        - [2.1.4 将i节点和file_table[64]建立联系](#214-将i节点和file_table64建立联系)
        - [2.1.5 将管道文件句柄返回给用户进程](#215-将管道文件句柄返回给用户进程)
    - [2.2 管道操作](#22-管道操作)
        - [2.2.1 读管道进程开始操作文件](#221-读管道进程开始操作文件)
        - [2.2.2 写管道进程向管道中写数据](#222-写管道进程向管道中写数据)
        - [2.2.3 写管道进程继续向管道中写入数据](#223-写管道进程继续向管道中写入数据)
        - [2.2.4 写管道进程已将写管道空间写满](#224-写管道进程已将写管道空间写满)
        - [2.2.5 写管道进程挂起](#225-写管道进程挂起)
        - [2.2.6 读管道进程从管道中读出数据](#226-读管道进程从管道中读出数据)
        - [2.2.7 读管道进程继续执行，不断从管道数据中读出数据](#227-读管道进程继续执行不断从管道数据中读出数据)
        - [2.2.8 读管道进程执行中发生中断](#228-读管道进程执行中发生中断)
        - [2.2.9 写管道进程挂起，切换到读管道进程中执行](#229-写管道进程挂起切换到读管道进程中执行)
        - [2.2.10 读管道进程继续执行，直到把管道中的数据读完](#2210-读管道进程继续执行直到把管道中的数据读完)
- [3. 信号机制](#3-信号机制)
    - [3.1 信号的使用](#31-信号的使用)
        - [3.1.1 processing 进程开始执行](#311-processing-进程开始执行)
        - [3.1.2 processing函数进入可中断状态](#312-processing函数进入可中断状态)
        - [3.1.3 sendsig进程开始执行，并向processing进程发送信号](#313-sendsig进程开始执行并向processing进程发送信号)
        - [3.1.4 系统检测当前进程接收到信号并处理](#314-系统检测当前进程接收到信号并处理)
        - [3.1.5 系统检测信号处理函数指针挂接是否正常](#315-系统检测信号处理函数指针挂接是否正常)
        - [3.1.6 调整processing 进程内核栈结构，使其系统调用后返回，先执行信号处理函数](#316-调整processing-进程内核栈结构使其系统调用后返回先执行信号处理函数)
    - [3.2 信号对进程执行状态的影响](#32-信号对进程执行状态的影响)
        - [3.2.1 可中断状态](#321-可中断状态)
        - [3.2.1.1 用户进程退出，并向shell进程发送信号（可中断）](#3211-用户进程退出并向shell进程发送信号可中断)
        - [3.2.1.2 shell进程被唤醒并调度执行](#3212-shell进程被唤醒并调度执行)
        - [3.2.1.3 shell进程执行，为子进程退出做最后处理](#3213-shell进程执行为子进程退出做最后处理)
        - [2.3.1.4 shell进程被挂起](#2314-shell进程被挂起)
        - [2.3.2 不可中断状态](#232-不可中断状态)
            - [2.3.2.1 进程A由于等待读盘被挂起](#2321-进程a由于等待读盘被挂起)
            - [2.3.2.2 进程A切换到进程B去执行](#2322-进程a切换到进程b去执行)
            - [2.3.2.3 进程A收到信号，但无法唤醒](#2323-进程a收到信号但无法唤醒)
            - [2.3.2.4 外设数据读取完毕，进程A被唤醒](#2324-外设数据读取完毕进程a被唤醒)
            - [2.3.2.5 切换到进程A执行并处理信号](#2325-切换到进程a执行并处理信号)
- [3. 总结](#3-总结)

<!-- /TOC -->
# 1. 背景
这章非常重要，通信的速度在超算领域有非常多的优化地方。前提是理解通信的基本原理。

* 前面讲述过，通过进程隔离来实现进程保护，但是进程之间通信好像和进程保护的思想相悖。

* 如何才能做到不破坏进程保护，又能实现进程间通信的合理要求。linux0.11设计两套方法，一套是管道机制，一套是信号机制。

# 2. 管道机制
为了体现对进程保护，在不跨越进程边界检查前提下实现进程通信，linux0.11绕过对进程的边界保护，设计了管道机制。

一个管道运行两个进程交互数据，一个进程向管道输入数据，一个进程向管道输出数据。该机制实现进程间通信，同时不需要非法跨越进程边界。

操作系统在为每个管道开辟一个内存，给这个页内存分配文件属性(为什么赋予文件属性，下一章讲解)。折页由两个进程共享，但不会分配给任何进程，只由内核掌握。

在linux0.11中，管道操作分为两部分，创建管道和读写管道。
* 下面例子中pid值区分父子进程针对是用的非常经典。
![2019-09-05-10-37-38.png](./images/2019-09-05-10-37-38.png)
![2019-09-05-10-38-08.png](./images/2019-09-05-10-38-08.png)
![2019-09-05-10-38-26.png](./images/2019-09-05-10-38-26.png)

## 2.1 管道的创建过程

* 从技术来看，管道就是一页内存，但进程要以文件的方式对其进行操作，这就要求折页内存具备文件属性，并减少页属性。
    * 具备文件属性表现为，创建管道相当于创建一个文件，filp[20],file_table[64],inode_table[32]以及之间的挂接都需要完成。最终要使进程知道自己操作的是一种管道类型的文件就行，其它的都不需要操作。

    * 减少页属性表现在管道毕竟要作为一个文件使用，进程不能像访问进程空间数据访问它，不能映射到进程的线性地址空间。另外，两个进程操作这个页面，必须一个读一个写，不能产生页写保护异常把页复制一份，否则无法共享管道。

### 2.1.1 为管道文件在file_table[64]中申请空闲项
* 创建文件是为当前进程服务（一个），管道文件就是两个进程服务

上面例子，管道是由父进程创建的，父进程创建管道时，处处为子进程着想，使得子进程一旦创建完毕就有操作管道能力。

父进程先在file_table[64] 申请两个空闲项，并将这两个空闲项的引用计数设置为1，表示他们被引用了，父子进程以后操作管道文件各用一项。

![2019-09-05-11-21-09.png](./images/2019-09-05-11-21-09.png)


### 2.1.2 进程中task_struct的filp[20]和file_table[64]挂接

父进程filp[20]挂接file_table[64]后，子进程继承父进程的关系。
![2019-09-05-11-25-55.png](./images/2019-09-05-11-25-55.png)

### 2.1.3 创建管道文件i节点
* 创建file_table[64]和inode节点之间关系
* 调用get_pipe_inode()先为该管道文件在inode_table[32]申请一个i节点，执行代码如下
![2019-09-05-11-31-20.png](./images/2019-09-05-11-31-20.png)
* 由于管道不是文件，本质上是一个内存页面，  并将该页面地址载入i节点。值得注意的是， inode_size不再是文件大小，而是内存页面的起始地址
![2019-09-05-11-34-08.png](./images/2019-09-05-11-34-08.png)
![2019-09-05-11-34-18.png](./images/2019-09-05-11-34-18.png)

* 读写指针都指向内存页起始地址（inode_size）
* 设置indoe类型为管道类型，方便以后标识管道类型的特殊性

![2019-09-05-11-40-35.png](./images/2019-09-05-11-40-35.png)

### 2.1.4 将i节点和file_table[64]建立联系
* file_table[64]申请的两个空闲项都指向这个inode节点,第一个空闲指针设置为读，第二个空闲指针设置为写。
![2019-09-05-11-46-30.png](./images/2019-09-05-11-46-30.png)

### 2.1.5 将管道文件句柄返回给用户进程
现在将管道文件的两个句柄返回给用户进程（用户进程无法直接操作filp[20],因为实在内核区），即实例中的fd[2].
![2019-09-05-15-53-09.png](./images/2019-09-05-15-53-09.png)
![2019-09-05-15-53-20.png](./images/2019-09-05-15-53-20.png)

## 2.2 管道操作
linux 0.11管道操作的效果是:
* 读管道进程执行时，如果管道中有未读数据就读数据，没有未读数据就挂起。
* 写管道执行时，如果管道中有剩余空间，就继续写数据，没有剩余空间，就挂起。
* 管道只有一个页面，如果读写指针到页面微端，读写指针要回滚到页面首端以便继续操作。

![2019-09-05-16-41-04.png](./images/2019-09-05-16-41-04.png)
![2019-09-05-16-41-27.png](./images/2019-09-05-16-41-27.png)

在不断回滚操作的前提下，控制写入和读取，以及将进程唤醒和挂起的代码如下。
![2019-09-06-09-25-20.png](./images/2019-09-06-09-25-20.png)
![2019-09-06-09-25-41.png](./images/2019-09-06-09-25-41.png)

当管道中所有空间被写满时，写管道指针回滚一圈，与读管道指针差1字节，这时应该把写管道进程挂起。linux 0.11将sys_write()函数设计为写管道进程一次最多只能写4095字节。

### 2.2.1 读管道进程开始操作文件
假设读管道进程开始执行，此时管道中没有任何数据，执行read()->sys_read()->read_pipe()时会因为管道中没有任何数据被挂起。
![2019-09-06-09-36-17.png](./images/2019-09-06-09-36-17.png)
![2019-09-06-09-36-30.png](./images/2019-09-06-09-36-30.png)

### 2.2.2 写管道进程向管道中写数据
切换到写管道进程中执行，write()->sys_write()->write_pipe(),写完后管道中就有数据可以读出，唤醒读管道进程。
![2019-09-06-09-39-23.png](./images/2019-09-06-09-39-23.png)
![2019-09-06-09-39-34.png](./images/2019-09-06-09-39-34.png)

### 2.2.3 写管道进程继续向管道中写入数据
当前进程是写管道进程，写完一次管道之后将会返回用户空间。有例子中的for(i = O;i< 1 OOOO;i++）我们知道一共要写10000次，写管道进程时间片还没有用完，还需要继续执行写管道。

### 2.2.4 写管道进程已将写管道空间写满
不放在写管道进程工作过程中，发生了时间中断，消减了它的时间片，只要时间片不被消减为0，就会继续执行。
![2019-09-06-10-05-40.png](./images/2019-09-06-10-05-40.png)

### 2.2.5 写管道进程挂起
写满后，系统要将写管道进程挂起，切换到读管道进程中执行。
![2019-09-06-10-08-16.png](./images/2019-09-06-10-08-16.png)

### 2.2.6 读管道进程从管道中读出数据
读管道进程开始执行read_pipe()函数，这次会将512个字节读入管道进程的用户空间。
![2019-09-06-10-19-44.png](./images/2019-09-06-10-19-44.png)

读出数据，意味着有了剩余空间，系统此时会唤醒写管道进程
* 唤醒管道进程不是立马切换到写管道进程执行，只是将写管道进程改成就绪态，此时任然是读管道进程在运行
![2019-09-06-10-23-05.png](./images/2019-09-06-10-23-05.png)
![2019-09-06-10-23-17.png](./images/2019-09-06-10-23-17.png)

### 2.2.7 读管道进程继续执行，不断从管道数据中读出数据
由于for循环20000次，因此读管道进程会不断的从管道中读数据，直到时间片为0

### 2.2.8 读管道进程执行中发生中断
假设在读管道进程工作过程中，也发生了时间中断，消减了她的时间片。读进程时间片为0之后，切换到写管道进程中继续执行。
![2019-09-06-10-34-35.png](./images/2019-09-06-10-34-35.png)

### 2.2.9 写管道进程挂起，切换到读管道进程中执行
* 假设，写管道进程时间片再次用完。此时读写管道进程时间片都为0，那么需要再分配时间片。
* linux0.11规定，当所有就绪态进程时间片都是0时，就分配进程。
![2019-09-06-11-14-15.png](./images/2019-09-06-11-14-15.png)
![2019-09-06-11-14-28.png](./images/2019-09-06-11-14-28.png)

### 2.2.10 读管道进程继续执行，直到把管道中的数据读完
读管道进程开始执行后，继续将管道中的数据读出，当操作到管道尾端，也会将管道指针从尾端移动到首端，并从首端继续读管道中内容，知道彻底读完管道中数据，使读写指针重合。

![2019-09-06-11-20-39.png](./images/2019-09-06-11-20-39.png)
![2019-09-06-11-20-50.png](./images/2019-09-06-11-20-50.png)


* 进程数量不超过64，打开文件不超过file_table[64],就能创建任意的管道数

# 3. 信号机制
* 信号机制是进程在执行过程中，如果系统发现某个进程收到了信号，就暂时打断进程的执行，转去执行该进程的信号处理程序。处理完毕后，再从进程“被打断”之处执行。


本节分两部分对信号量机制进行详细介绍
* 通过下面例子，对系统和进程处理信号的过程进行详细介绍
* 系统通过对信号的分析，改变对进程的执行过程

这是一个信号发送、接收、处理实例。假设有两个进程分别用于发送和接受处理信号。
* processing:接收信号
![2019-09-06-11-44-25.png](./images/2019-09-06-11-44-25.png)
![2019-09-06-11-45-03.png](./images/2019-09-06-11-45-03.png)
* sending:发送信号
![2019-09-06-11-45-40.png](./images/2019-09-06-11-45-40.png)


系统需要支持下面三个功能，才能支持信号量机制：
* 系统支持信号的接收和发送
    * 每个task_struct都设置用户接收信号的数据成元signal（信号位图），每个进程接收的信号就“按位”存储在这个数据结构中
    * 系统支持两种方式发送信号
        * 一种是调用特定函数库给另一个进程发送信号
        * 另一种是用户键盘输出信息后产生键盘中断后，中断服务程序给进程发送信号
        * 这两种方式原理相同，都是通过设置信号位图上的信号位来实现的
    
* 系统要及时检测到进程接收到信号，有两种方式检测进程是否接收到信号
    * 一是系统调用返回之前检测当前进程是否接收到信号
    * 另一种是时钟中断产生后，中断服务程序执行接收之前，检测当前进程时候接收到信号。
    * 两种方式检测过程一致，本例通过第一种方式来展现系统对进程对接收信号的检测。

* 系统支持进程对信号处理
    * 当进程不需要处理信号时，信号处理函数完全不参与用户进程执行
    * 当用户进程需要处理信号时，进程的程序将暂时停止执行，转而去执行信号处理函数，待信号处理函数执行完毕后，进程程序将从“暂停的现场处”继续执行

本例将从用户自定义的信号处理函数与进程进行绑定，系统对信号的预处理，信号处理完毕后的现场恢复三个方面展现系统是如何做到这些的。


下面是两个进程是如何开始运行的
* ./processing &(显示执行的进程号是160)
* ./sendsig 10 160(10代表的是SIGUSR1信号，160代表processing进程ID)


## 3.1 信号的使用
### 3.1.1 processing 进程开始执行
* processing 开始执行时，要为接收信号做准备，具体表现为对那种信号进行什么样的处理
* 进入main函数后，先将用户定义的信号处理函数与processing进程绑定。用户调用signal实现这个绑定。signal是一个系统调用，发生int0x80，并映射到sys_signal()这个系统调用函数执行

* 进入sys_signal()函数后，系统先要检测在绑定之前检测用户指定的信号是否符合规定。linux0.11只能处理32种信号，而且默认忽略SIGKILL这个信号
![2019-09-06-14-07-19.png](./images/2019-09-06-14-07-19.png)

* 检测完毕，开始对processing进程task_struct中的sigaction[32]进行设置，该管理结构有32个成员，正好对应32中信号。sigaction[32]每一种成员都会为每一种信号处理提供一种服务。
    * restore()函数也在sys_signal()函数中绑定了，restore()函数功能页非常重要

![2019-09-06-14-11-15.png](./images/2019-09-06-14-11-15.png)

### 3.1.2 processing函数进入可中断状态
为了体现信号对进程状态影响，这里特意调用pause()将进程由就绪态转变成可中断状态，等到进程收到信号后，进程由可中断切换成就绪态。

![2019-09-06-14-18-00.png](./images/2019-09-06-14-18-00.png)

### 3.1.3 sendsig进程开始执行，并向processing进程发送信号
processing进程暂时挂起，sendsig进程执行， sendsig进程会给processing进程发送信号然后切换到processing进程执行。

* 执行kill(pid,signo)这行代码，其中kill是一个函数库，最终映射到sys_kill函数中去执行
![2019-09-06-14-33-26.png](./images/2019-09-06-14-33-26.png)

* 之后继续在sendsig进程空间随着时间中断不断产生，sendsig进程时间片被消减为0，调用导致进程切换schedule()函数开始执行
![2019-09-06-14-36-09.png](./images/2019-09-06-14-36-09.png)
![2019-09-06-14-36-20.png](./images/2019-09-06-14-36-20.png)

* 等到第二次遍历时，就切换到processing执行
![2019-09-06-14-39-45.png](./images/2019-09-06-14-39-45.png)

### 3.1.4 系统检测当前进程接收到信号并处理
processing进程开始执行后，会继续在for(){pause()},这个函数会最终映射到sys_pause()系统调用中执行，所以当系统调用返回时，就一定会执行到ret_from_sys_call标号处，最终调用do_signal,开始处理processing进程信号。

![2019-09-06-14-46-08.png](./images/2019-09-06-14-46-08.png)


### 3.1.5 系统检测信号处理函数指针挂接是否正常
现在开始介绍信号处理之前准备工作。
进入do_signal()函数后，先对processing进程信号处理函数进行判定。我们在本节前面介绍过，processing进程信号处理函数指针被加载到进程task_struct中sigaction[32]结构中。

现在这个指针开始发挥作用，如果他为null，进程很有可能退出。当然，此时这个指针肯定不是空，它指向sig_usr()函数，检测对应的代码如下
![2019-09-06-14-57-12.png](./images/2019-09-06-14-57-12.png)


### 3.1.6 调整processing 进程内核栈结构，使其系统调用后返回，先执行信号处理函数
* 这里所做核心工作核心目的是对用户栈数据进行调整，使得此次系统调用返回执行先执行processing的信号处理函数，然后从用户中断位置继续执行。

* 软中断后，cpu将自动在当前进程内核栈保存当前寄存器的数据“EIP、CS、EFLAGES、ESP、SS”这些寄存器的值。这样系统调用返回“内核栈”中这些数据值返回给对应的寄存器。

* 面对信号处理情况，内核先将内核栈中保存的寄存器值备份到用户栈中。然后对内核栈中原有寄存器值进行修改，使得系统调用返回后返回的是用户空间的信号处理函数。信号处理函数处理完毕后，用户栈的数据就其作用，再通过前面备份在用户空间的寄存器值返回到“中断处理位置”。

![2019-09-06-15-30-53.png](./images/2019-09-06-15-30-53.png)


* 前面我们已经将sig_usr和processing进行绑定，当sig_usr信号处理函数执行完毕之后，就需要执行ret指令。这时我们处于sa-sa->restore所代表的函数地址就发挥作用。

* restore是一个库函数地址，是signal传递进来的参数，这个函数会恢复用户进程执行的“指令和数据”，最终跳转到用户进程的“中断位置”处执行。
![2019-09-06-15-41-06.png](./images/2019-09-06-15-41-06.png)

最终返回到processing进程中断位置去执行。


## 3.2 信号对进程执行状态的影响

下面以可中断状态和不可中断状态为例对比，体现信号量对进程执行状态的不同影响。

### 3.2.1 可中断状态
可中断代码如下，该进程是shell进程的子进程，并且是可中断状态
![2019-09-06-15-44-54.png](./images/2019-09-06-15-44-54.png)


### 3.2.1.1 用户进程退出，并向shell进程发送信号（可中断）
用户进程先调用exit()来处理自身退出前的一些事物，包括将内存页面释放、解除该进程和操作文件关系，之后给shell进程发出“子进程退出”信号，最后将自己设置成僵死状态，并调用schedule()函数准备进程切换。

![2019-09-06-15-50-47.png](./images/2019-09-06-15-50-47.png)
![2019-09-06-15-50-57.png](./images/2019-09-06-15-50-57.png)

### 3.2.1.2 shell进程被唤醒并调度执行

和前面唤醒processing进程一致，第一遍遍历将shell进程由可中断状态编程就绪态，第二遍遍历切换到shell进程区执行。
![2019-09-06-15-53-56.png](./images/2019-09-06-15-53-56.png)
![2019-09-06-15-54-06.png](./images/2019-09-06-15-54-06.png)
![2019-09-06-15-54-22.png](./images/2019-09-06-15-54-22.png)

### 3.2.1.3 shell进程执行，为子进程退出做最后处理
shell进程开始执行后，调用wait()函数为子进程退出做准备。包括将子进程的task_struct所占的页面释放掉。
![2019-09-06-16-01-08.png](./images/2019-09-06-16-01-08.png)


### 2.3.1.4 shell进程被挂起
shell进程继续执行，从tty0终端读数据，但由于此时终端没有任何数据，于是shell进程将被设置为可中断状态，等待下一次被唤醒。



### 2.3.2 不可中断状态
下面开始介绍进程的不可中断状态，假设A、B、C三个用户进程都是处于就绪态，假设B是A的子进程，进程A正在运行。
* 进程A、B运行案例如下
![2019-09-06-16-09-08.png](./images/2019-09-06-16-09-08.png)
* 进程C运行案例如下
![2019-09-06-16-09-23.png](./images/2019-09-06-16-09-23.png)


#### 2.3.2.1 进程A由于等待读盘被挂起
进程调用sys_read()产生软中断，同时进程A被设置成不可中断状态，这时因为进程A下一步执行需要读盘数据来支持，在数据读出之前，无论这个进程收到什么信号，都不能被唤醒。如果被唤醒，将操作缓冲区中数据，会导致数据混乱。
* 设置成不可中断状态，只是说明进程不能轻易被唤醒，而不是不能参与schedule切换到其它进程（那么不可中断状态是如何被唤醒的呢？）

![2019-09-06-16-15-28.png](./images/2019-09-06-16-15-28.png)

#### 2.3.2.2 进程A切换到进程B去执行
之后切换到进程B执行，进程B执行完毕，将自己设置成僵死状态，之后给A信号，告诉A自己将要退出了。
然后调用schedule()函数进行切换。
![2019-09-06-16-21-49.png](./images/2019-09-06-16-21-49.png)


#### 2.3.2.3 进程A收到信号，但无法唤醒
进入schedule函数，第一次遍历所有进程，但是由于她是不可中断状态，所以并不将其设置为就绪态，只能切换到进程C去执行。
![2019-09-06-16-23-58.png](./images/2019-09-06-16-23-58.png)


#### 2.3.2.4 外设数据读取完毕，进程A被唤醒
进程C执行一段时间后，进程A指定的数据被读出，于是硬盘中断服务程序将进程A强行设置为就绪态。（将不可中断状态设置成就绪态的唯一办法）
![2019-09-06-16-27-14.png](./images/2019-09-06-16-27-14.png)

#### 2.3.2.5 切换到进程A执行并处理信号
处理进程B退出信号和前面一致。

# 3. 总结
进程间通信本应是操作系统比较难以掌握的内容,但 Linux 0 . 11 的进程间通信设计的比较简单。俗话说,麻雀虽小,五脏俱全。读者可以依托这个虽然简单却可实际运行的进程间
通信模型,进一步深入理解高版本的进程间通信问题。

信号是操作系统中很重要的概念 。 本章详细讲解了信号机制,井提出了信号是仿软中断
的理解。

# 1. 背景
* 多进程执行需要解决问题
    * 多个进程运行一个程序代码，进程之间不进行干扰（进程保护）
    * 如果让多个进程轮流执行（进程调度）

# 2. 线性地址保护
## 2.1 线性地址空间设计格局
* 进程隔离实现：通过地址划分实现隔离。Linux 0.11将32位地址分为64个64MB的区域，每个进程一份，进程之间彼此不能重叠。

* task[64]是进程管理格局基点，所有进程等级和注销都是由他管理。task[64]想好nr在GDT找到对象的项，然后找到LDT。task[64]对控制进程总量和关联GDT和LDT、TSS有着重要作用。

* 能够实现进程之间的跨界访问。软件是很难实现的，因为软件的指令访问区间只能在本身64MB内。这样跨界访问就需要硬件实现（很显然CPU是最常使用的）

## 2.2 段基址、段限长、GDT、LDT、特权级
* 早起CPU只设置了段首寄存器，后面CPU为了继承也没有设置断尾寄存器，而是设置段限长来起到相同作用。如果访问地址之前先进行地址检查。

### 2.2.1 跨界地址访问
#### 2.2.1.1 一个进程非法跨到另外一个进程
* GDT、LDT保护，GDT中没有存储每个进程CS地址，LDT（第一项空、第二项代码段、第三项数据段），因此每个进程只知道当前CS段地址，跳转也只能在当前进程空间跳转。
* 如果希望进程见调用，只能通过进程切换实现，很显然需要使用中断。

## 2.2 分页
### 2.2.1 线性地址映射到物理地址

* 前面在怠速前打开PG，线性地址通过页目录表-页表-页内地址三级映射，最终落实到物理地址。
* 在打开PG前，已经打开PE，转入到保护模式运行。CPU的硬件默认，在保护模式下，如果没有打开PG，线性地址恒等映射到物理地址。如果打开PG，线性地址需要经过MMU解析，以页目录表，页表，页面三级映射模式映射到物理地址。

* linux-0.11线性地址空间是4G，而实际物理地址是16M，显然PG模式是为了实现虚拟地址。
![2019-08-28-15-13-11.png](./images/2019-08-28-15-13-11.png)
    * linux-0.11只有一个页目录表，页目录表首地址存放在CR3寄存器中，显然打开PG模式首先是将页目录表首地址加载到CR3寄存器中
![2019-08-28-15-15-15.png](./images/2019-08-28-15-15-15.png)

### 2.2.2 进程执行时分页

* 分页以及映射到物理页时，内核需要做到一下几点
    * 必须要从空闲页中分配页面，不能分配其它进程正在使用页面
    * 不能挪用内核区页面

怠速前，内核通过mem_map 对1M以上内存进行分页管理，主内存每个页面引用计数都被初始化为0，默认空闲页。
![2019-08-28-15-53-19.png](./images/2019-08-28-15-53-19.png)

* 在为进程分配页面时，只能在mem_map管理范围上区申请空闲页面（为0），申请之后记为1.
![2019-08-28-16-01-52.png](./images/2019-08-28-16-01-52.png)

![2019-08-28-16-05-22.png](./images/2019-08-28-16-05-22.png)
![2019-08-28-16-05-37.png](./images/2019-08-28-16-05-37.png)
![2019-08-28-16-05-50.png](./images/2019-08-28-16-05-50.png)
![2019-08-28-16-06-02.png](./images/2019-08-28-16-06-02.png)

### 2.2.3 什么时候为进程申请新的页面
* 下面中没有看到页面替换思想，如果缺页，就直接申请页面，没有考虑替换已有一面

* 每个页目录项、页表项最后3为标志着其所管页面属性，分别表示U/S、R/W、和P。判断该页是否申请页面，是在解析线性地址时确定的，关键是看P标志位。
    * 如果P标志为1，说明该页表项已经和物理页面建立关系，直接取得线性地址就行
    * 如果P标志为0，说明没有物理页面对应，此时就产生缺页中断
![2019-08-29-09-44-23.png](./images/2019-08-29-09-44-23.png)
![2019-08-29-09-44-40.png](./images/2019-08-29-09-44-40.png)

* 7的二进制形式是111，P被设置成1
创建页面时，会调用页面，只要调用get_free_page()函数，把内存清0。
![2019-08-29-09-47-49.png](./images/2019-08-29-09-47-49.png)

复制页表时，就得建立映射关系，关系建立之后，就把P设置成1.
![2019-08-29-09-54-52.png](./images/2019-08-29-09-54-52.png)

页表和页面的关系解除后 ,页表项就要 清零。页目录项和页表解除关系后,页目录项也
要请零,这样就等于把对应的页表项、页目录项的 P 清零了。
![2019-08-29-09-56-56.png](./images/2019-08-29-09-56-56.png)
![2019-08-29-09-57-11.png](./images/2019-08-29-09-57-11.png)

比如在进程加载程序阶段,就调用了 free_page_tables( )函数把对应的页表项、页目录项
的 P 清零了,这样,当前进程线性地址对应的页面不存在,进程开始执行程序时,必产生缺
页中断。
进程加载程序后,与新页面建立了映射关系, P 位被设置成 1 ,代码如下:
![2019-08-29-10-11-01.png](./images/2019-08-29-10-11-01.png)


### 2.2.4 为进程申请的页面要映射到线性地址空间
* 页目录表2014项、每个页表1024项，一页4Kb，所有地址空间是1024*1024*4K=4G
* 将地址空间分成64等分，每个进程占用16个页目录项，正好等分，所以进程空间会分页在不同的物理页面上
* 不同的地址空间运行映射到同一个物理页面上



## 2.3 共享页面
正常情况下，不能进程划分不同页面，但是有些情况需要进程之间共享页面，比如父子进程之间的继承关系，如何实现页面共享呢？

* 此时最好的选择是，子进程创建完毕后沿用父进程代码，父进程有多少页面，子进程就共享多少，将来子进程加载自身程序，再进行映射。
* 这样的问题是，多进程操作一个页面，对进程独立性造成破坏。Linux 0.11中页表中U/S、R/W两个标志位能解决这个问题
### 2.3.1 U/S位
目的是组织内核才能访问的页面被用户进程访问
* U/S位0，表示特权级为3进程不可以访问该页面，其它进程可以
* U/S为1，所有进程都可以访问页面

怠速进程为内核分页时，U/S位为1
![2019-08-29-10-51-09.png](./images/2019-08-29-10-51-09.png)
![2019-08-29-10-51-20.png](./images/2019-08-29-10-51-20.png)

在创建子进程时，子进程页目录项和页表项U/S位都被设置成1.
![2019-08-29-10-55-08.png](./images/2019-08-29-10-55-08.png)

进程执行时，为进程新申请页面，并把页面映射到线性地址空间。申请的页目录项和页表项的U/S位都会设置成1.
![2019-08-29-11-01-16.png](./images/2019-08-29-11-01-16.png)


### 2.3.2 R/W位
R/W为0说明只能读不能写，R/W为1说明可读可写。
进程是可以共享页面的，这样会带来一些问题，如果多个进程往一个页面写数据，那么数据会造成混乱。R/W就是提供读写保护。
创建进程时，父子进程共享页面，这些共享页面就不能写入数据，R/W就设置为0.
![2019-08-29-11-15-14.png](./images/2019-08-29-11-15-14.png)

没有父子关系的两个进程也可以共享页面，这时候也需要将R/W置为0
![2019-08-29-11-18-12.png](./images/2019-08-29-11-18-12.png)
![2019-08-29-11-18-24.png](./images/2019-08-29-11-18-24.png)

上面我们知道，多个进程共享页面时，设置成自读无所谓，关键是如何实现写。Linux 0.11采用一套写时复制的策略来解决，即要把写入数据页面再复制一份给进程，两个进程各一个，这样就不会造成混乱，具体在下面讲解。

Linux中也有在通过管道在一个页面中又读又写，这在进程之间通信讲解（但是不属于内存共享的内容了）。


## 3.4 内核分页
内核区数据段和代码段大小都是16MB，需要四个页目录项来管理页表。
![2019-08-29-11-27-34.png](./images/2019-08-29-11-27-34.png)
![2019-08-29-12-26-46.png](./images/2019-08-29-12-26-46.png)

* 内核程序逻辑地址从0开始，刚好内核页的其实地址是从0开始，这样内核线性地址和物理地址是相等的，这样内核可以对内存中任意进程所有内存区域进行访问。

* 内核空间的线性地址和用户空间线性地址不一样。内核不能直接使用线性地址访问任意进程的任意地址空间。但是内核可以权限调用程序访问任意进程的数据。

* 内核肯定是能访问LDT等用户空间所有数据，但不是因为内核跨越了线性地址段。基本上都是通过寄存器+汇编形式完成。


# 4. 一个进程从创建到退出的完整过程
## 4.1 创建str1进程
* 假设有一个程序叫str1，并且在shell中执行
### 4.1.1 为创建str1准备条件
* shell调用fork开始创建进程
* 产生int0x80软中断，最终映射到sys_fork()上
* 调用find_empty_process()为str1程序申请一个可用的进程号，在task[64]申请一个空闲位置（进程号可能和task索引号不一致，因为进程号是last_pid+1,而task[64]是寻找空闲位置）

后面将根据task_struct的项号确定str1处于什么64M地址空间，LDT和TSS将和GDT哪两项挂载。

### 4.1.2 为str2进程管理结构寻找存储空间
* copy_process()函数第一件事情就是为str1申请一个页面，这个页面用来承载task_struct和内核栈。
    * 每个进程都有一个task_struct,每个进程都有这样一本帐，以保证进程之间互相独立不干扰。
    * 进程转入内核后，执行代码都是内核代码。但是执行路径未必相同，因此压栈出栈顺序不同，所有内核为每个进程都设置一个内核栈。

* 从内核分页过程已知，所有页面在刚进入PE保护模式时，就已经映射到16M线性地址空间。在内核调用get_free_page()为task_struct和进程内核栈分配的页面是在内核中分配的页。因此这个页面只能内核代码访问。

* task[64]存放了task_struct地址，因此我们可以根据进程号，找到进程有关信息。

### 4.1.3 Shell进程给str1进程复制task_struct结构
* Linux0.11设计来看，整个操作系统只有进程，内核是进程延续。
* 任何时候都要有一个进程工作，current永远指向当前进程。同时创建进程工作也由当前进程完成。
* shell给str1进程创建task_struct本质上是将自身的task_struct复制给str1
![2019-08-29-15-55-15.png](./images/2019-08-29-15-55-15.png)
* 由于每个进程task_struct中的数据信息是不一致的，所以还要对str1的task_struct进行初始化设置。
* 进行初始化设置时首先要将进程设置成不可中断状态（因为如果设置成可中断的，初始化未完成，再次切换到该进程，该进程可能运行故障）（设置见上面代码）

### 4.1.4 个性化设置task_struct
task_struct结构中还有其它字段需要个性化设置。
* str1进程号、父进程号和shell进程的值都不一样
* 时间片：shell进程已经执行过一段时间，时间片可能减少。str1不能继承shell时间片，而是根据shell优先级确定时间片。如果优先级没有被指定过，就和原始值一致即15
![2019-08-29-16-10-18.png](./images/2019-08-29-16-10-18.png)

* 对信号进行设置:task_struct关于信号有3个字段，signal、sigaction[32]、blocked，分别标识信号位图，信号处理函数挂接点和信号屏蔽码。
    * 创建str1进程，只是把signal清0。首先不能使用父进程shell信号位图。str1如果执行到内核，返回之前要进行信号处理，如果使用shell进程的信号位图，可能会多很多不必要的信号处理。
    * 我们将信号位清0，就没有必要设置信号处理函数挂载点和信号屏蔽码

*TSS字段设置
    * 进程切换寄存器值都是保存在TSS中
    ![2019-08-29-16-27-10.png](./images/2019-08-29-16-27-10.png)
    ![2019-08-29-16-27-25.png](./images/2019-08-29-16-27-25.png)

    * 这些值设置是CPU自动完成的，我们在内核中找不到给寄存器赋值代码。CPU是怎么知道那个值赋值给那个寄存器？只有一种可能，就是TSS字段设置都是事先规定好的。


### 4.1.5 复制task_struct页表并设置对应的页目录项
现在调用copy_mem为进程分段，确定线性地址空间。确定线性地址空间，关键在于确定段基址和段限长。
![2019-08-29-16-39-28.png](./images/2019-08-29-16-39-28.png)
* 上面代码中设置了段基址，但没有设置段限长。因为段限长是设置在LDT中的，复制task_struct时，已经将LDT复制过来。

下面开始分页，分页建立在分段的基础之上，表现在分段时间段基址和段限长为分页分别确定了从哪开始复制页表信息，复制到那里去和复制多少的问题。

* 上面代码中copy_page_tables就是分页过程。但是此时str1进程并没有自己程序，复制页面表现在复制父进程页表项内容，指向父进程相同的页表内容。
![2019-08-29-16-52-15.png](./images/2019-08-29-16-52-15.png)

    * 为新进程创建页表时，还需要调用get_free_page()函数申请页面，上面的复制页表体现在复制页表项。
    * str1申请的页面本质上是页表项（归内核管）。str1不能访问。

* 分段分页完成之后还有文件继承问题，shell打开的文件，子进程全部继承。表现为文件引用计数和i节点引用计数加1.
![2019-08-29-17-28-39.png](./images/2019-08-29-17-28-39.png)

### 4.1.6 建立str1进程和全局描述符（GDT）关联
* 文件继承好之后，将str1进程TSS、LDT挂接在GDT指定位置处
![2019-08-29-17-33-02.png](./images/2019-08-29-17-33-02.png)

### 4.1.7 将str1进程设置为就绪态
创建进程1工作基本结束，将其设置为就绪态，就可以参与轮转。
![2019-08-29-17-35-44.png](./images/2019-08-29-17-35-44.png)





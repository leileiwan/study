<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 系统调用过程](#2-系统调用过程)
    - [2.1 系统调用的定义和实现位置](#21-系统调用的定义和实现位置)
    - [2.2 源码分析](#22-源码分析)
        - [2.2.1 ReadFile](#221-readfile)
        - [2.2.2 NtReadFile](#222-ntreadfile)

<!-- /TOC -->
# 1. 背景
* ReactOS 项目目标是开发出一个开源的Windows，不言而喻，他要实现的系统调用就是Windows那一套系统调用
* 本文要说的是ReactOS怎样实现系统调用，也就是用户应用程序怎样进入和退出内核，实现系统调用


# 2. 系统调用过程
* 下面以系统调用NtReadFile()为例，按“自顶向下”的方式，一方面说明如何阅读ReactOS源代码，一方面说明ReacOS如何实现系统调用。


## 2.1 系统调用的定义和实现位置
* Windows应用程序库都应该通过Win32API调用这个接口定义的所有库函数，这个库函数基本上在“动态链接库”即DLL中实现。
* 比如ReadFile()是Wine32 API 所定义的一个库函数，其实现在kernel32.dll库中，定义在winbase.h文件中

## 2.2 源码分析
### 2.2.1 ReadFile
*  ReadFile在Windows 中定义
```
WINBASEAPI BOOL WINAPI ReadFile(
    IN HANDLE hFile,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfBytesToRead, OUT LPDWORD lpNumberOfBytesRead, IN LPOVERLAPPED lpOverlapped
)
```
* ReactOS 代码同样有winbase.h，这里在目录reactos/w32api/include中
```
BOOL WINAPI ReadFile(HANDLE, PVOID, DWORD, PDWORD, LPOVERLAPPED);
```

* ReadFile 实现
微软没有开源这个函数代码，ReactOS为之提供了一个开源实现，代码在reactos/lib/kernel32/file/rw.c
![](./images/2019-12-13-10-54-17.png)




### 2.2.2 NtReadFile
* NtReadFile()是Windows的一个系统调用，它的实现在ntoskrnl.exe(这是window内核核心部分)
* ReactOS代码中内核函数NtReadFile()的定义在reactos/include/nots/zw.h中，同样的定义也出现在reactos/w32api/include/ddk/winddk.h:
![](./images/2019-12-13-11-03-52.png)

* 相应的实现在reactos/ntoskrnl/io/rw.c
    * 问题在于NtReadFile()实现在内核空间中，用户程序是如何调用内核空间代码的？
    * 因此这里面一定另外存在奥妙
* 作者发现，还有另外一个NtReadFile(),在msvc6/iface/native/syscall/Debug/zw.c
    ![](./images/2019-12-13-11-09-37.png)
    * 用户空间也存在NtFileRead()函数，正是这个函数执行自陷阱指令“int 0x2e”，下面我们分析下上面的汇编代码：
        * 152 是NtReadFile()这个系统调用的调用号，所以当CPU自陷阱进入到系统空间后，eax持有具体的系统调用号
        * 寄存器edx执行lea这条指令后，则持有CPU在调用这个函数前夕的堆栈指针，实际上就是指向堆栈中调用参数的起点
        * (在系统调用如何传递参数这个问题上，Windows和Linux有着明显的差别，Linux是通寄存器传递参数的，Windows则是通过堆栈传递，这样的直接结果是，Linux 参数传递受寄存器限制，因此linux系统调用参数一般都很少，如果有很多参数需要传递，一般都是先经过struct封装，然后传递struct指针)
        * 堆栈中参数目前任然是存在用户空间，进入系统调用后参数需要变成内核堆栈，因此需要使用copy_from_user()一类的函数吧这些参数从用户空间拷贝过来，此时edx值就可以作为源指针
        * ebp用户调用这个函数的“堆栈框架”指针
        * 当内核完成具体系统调用操作，然后指令ret 9使得cpu返回上一层函数，同时调整堆栈指针，使其跳过堆栈中的9个调用参数    
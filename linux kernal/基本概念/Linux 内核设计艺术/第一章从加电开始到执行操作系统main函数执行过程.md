[toc]

# 1. 背景
从加电到执行操作系统main函数主要分以下三步:
    * 启动BIOS，准备中断向量表和中断服务程序
    * 从启动盘加载操作系统到内存，加载工作就是有前面中断服务程序执行的
    * 执行main函数前做一些过渡工作


# 2. 启动BIOS，准备中断向量表和中断服务程序

## 2.1 BIOS
### 2.1.1 BIOS 启动

BIOS启动之前RAM中什么都没有，那么BIOS程序由什么来执行呢？（此时操作系统还未被加载）

* 既然先在程序中没有软件，那么就由硬件来执行程序。
* Intel 8086 系列芯片都被设计成加电进入16位实模式状态。同时非常关键的是CPU加电瞬间强行将CS值设计为0xF0000，IP设计为OxFFF0，这样CS:IP就指向0xFFFF0，这里正好指向BIOS地址范围。
* 0xFFFF0 必须是BIOS程序入口地址，如果不是，计算机就死机。

![2019-08-12-11-42-26.png](./images/2019-08-12-11-42-26.png)


### 2.1.2 BIOS在内存中加载中断向量表和中断服务程序

* BIOS程序量不大但是非常精深，并且要把很多硬件都了解清楚，这不是我想研究方向，因此下面只是理解加载中断向量表和中断服务程序。

* BIOS 是被固化在ROM中，启动BIOS后会进行检查显卡内存等工作，这期间执行非常重要的工作是建立中断向量表和中断服务程序。

* BIOS 在内存最开始1kb构建中断向量表，紧接着256B构建BIOS数据区，并在之后57kb左右位置加载中断服务程序
![2019-08-12-13-49-13.png](./images/2019-08-12-13-49-13.png)

* 中断向量表中有256个中断向量，每个中断向量4字节，前两字节标识CS，后两个字节标识IP，分别指向每一个中断服务程序起始地址。



# 3. 中断服务程序将操作系统内核程序加载在内存
* 中断向量表和中断服务程序都是BIOS事先设计好的。可以说中断服务程序就是BIOS中部分代码映射。（当断服务程序有BIOS加载，那么不同的BIOS有不同的中断服务程序？）

## 3.1 加载操作系统内核程序并为保护模式做准备
* boot操作：boot操作就是我们讲操作系统内核程序加载在内存中
* 对Linux 0.11操作系统而言，计算机分三步分别加载操作系统内核代码，第一批由BIOS中断int 0x19把第一扇区bootsect的内容加载在内核中，第二批、第三批在bootsect的指挥下分别将接下来的4个扇区和240个扇区分别加载在内存中

## 3.1.1 加载第一部分内核代码--引导程序（bootsect）

* 我们把硬盘设计为启动盘，计算机硬件体系结构设计和BIOS联合会生成一个int 0x19中断信号。
* CPU收到中断信号后，会立即找到中断向量表，然后找到中断服务程序，这个程序作用就是将硬盘中第一个扇区的程序加载在内存中的指定位置。（0号磁头，0号磁道1号扇区内容）。这个扇区内容就是操作系统引导程序（bootsect，第一个执行的Linux 内核代码，是用汇编写的）

* BIOS 是厂商决定的，不是由Linux 内核的人决定的。因此两边必须要有合适的协调机制，目前采用“两头约定”和“定位识别”
    * 操作系统：操作系统的启动程序必须定位在














# Q
##Q1 中断服务程序如何统一
中断向量表和中断服务程序是由BIOS加载在操作系统中的。那么不同的BIOS就由不同的中断服务程序吗？Linux 调用中断都是通过中断信号来的，如果我的中断向量表因为中断信号由BIOS设计不同意或者中断服务程序不同意，那么程序调用不同的中断是否会返回不同的结果
[toc]

# 1. 背景
从加电到执行操作系统main函数主要分以下三步:
    * 启动BIOS，准备中断向量表和中断服务程序
    * 从启动盘加载操作系统到内存，加载工作就是有前面中断服务程序执行的
    * 执行main函数前做一些过渡工作


# 2. 启动BIOS，准备中断向量表和中断服务程序

## 2.1 BIOS
### 2.1.1 BIOS 启动

BIOS启动之前RAM中什么都没有，那么BIOS程序由什么来执行呢？（此时操作系统还未被加载）

* 既然先在程序中没有软件，那么就由硬件来执行程序。
* Intel 8086 系列芯片都被设计成加电进入16位实模式状态。同时非常关键的是CPU加电瞬间强行将CS值设计为0xF0000，IP设计为OxFFF0，这样CS:IP就指向0xFFFF0，这里正好指向BIOS地址范围。
* 0xFFFF0 必须是BIOS程序入口地址，如果不是，计算机就死机。

![2019-08-12-11-42-26.png](./images/2019-08-12-11-42-26.png)


### 2.1.2 BIOS在内存中加载中断向量表和中断服务程序

* BIOS程序量不大但是非常精深，并且要把很多硬件都了解清楚，这不是我想研究方向，因此下面只是理解加载中断向量表和中断服务程序。

* BIOS 是被固化在ROM中，启动BIOS后会进行检查显卡内存等工作，这期间执行非常重要的工作是建立中断向量表和中断服务程序。

* BIOS 在内存最开始1kb构建中断向量表，紧接着256B构建BIOS数据区，并在之后57kb左右位置加载中断服务程序
![2019-08-12-13-49-13.png](./images/2019-08-12-13-49-13.png)

* 中断向量表中有256个中断向量，每个中断向量4字节，前两字节标识CS，后两个字节标识IP，分别指向每一个中断服务程序起始地址。



# 3. 中断服务程序将操作系统内核程序加载在内存
* 中断向量表和中断服务程序都是BIOS事先设计好的。可以说中断服务程序就是BIOS中部分代码映射。（当断服务程序有BIOS加载，那么不同的BIOS有不同的中断服务程序？）

## 3.1 加载操作系统内核程序并为保护模式做准备
* boot操作：boot操作就是我们讲操作系统内核程序加载在内存中
* 对Linux 0.11操作系统而言，计算机分三步分别加载操作系统内核代码，第一批由BIOS中断int 0x19把第一扇区bootsect的内容加载在内核中，第二批、第三批在bootsect的指挥下分别将接下来的4个扇区和240个扇区分别加载在内存中

### 3.1.1 加载第一部分内核代码--引导程序（bootsect）

* 我们把硬盘设计为启动盘，计算机硬件体系结构设计和BIOS联合会生成一个int 0x19中断信号。
* CPU收到中断信号后，会立即找到中断向量表，然后找到中断服务程序，这个程序作用就是将硬盘中第一个扇区的程序加载在内存中的指定位置。（0号磁头，0号磁道1号扇区内容）。这个扇区内容就是操作系统引导程序（bootsect，第一个执行的Linux 内核代码，是用汇编写的）

* BIOS 是厂商决定的，不是由Linux 内核的人决定的。因此两边必须要有合适的协调机制，目前采用“两头约定”和“定位识别”
    * 操作系统：操作系统的启动程序必须定位在启动扇区（0磁头、0磁道、0扇区），其余程序由操作系统设计加载
    * BIOS收到启动操作系统命令，只从启动扇区把程序加载在0x07c00（BOOTSEG）这个位置（参见Seabios 0.6.0//boot.c 代码中的boot_disk 函数），至于这个扇区中是否是启动程序，是什么操作系统boot不管

### 3.1.2 加载第二部分程序--setup

#### bootsect对内存规划
* 为了将第二批和第三批内核代码加载在内存中，bootsect代码首先要做的是内存规划

* 实模式下没有内存保护，setup首先要做的是设置不同代码段的地址范围，比如如下
![2019-08-12-14-58-30.png](./images/2019-08-12-14-58-30.png)
![2019-08-12-14-58-46.png](./images/2019-08-12-14-58-46.png)
    * SETUPLEN:setup程序扇区数
    * SETUPSEG:setup程序加载位置
    * BOOTSEG: 启动扇区(Bootsect)被扇区加载位置
    * INITSEG: 启动程序即将要移动的新位置
    * SYSSEG: kernal要被加载的位置
    * ENDSEG: 内核结束位置
    * ROOT_DEV: 根文件系统设备号

    上面这些地址都被bootsect明确的标识出来，确保即将加载的代码和已经加载代码在内存中的地址不会发生冲突

![2019-08-12-15-08-05.png](./images/2019-08-12-15-08-05.png)


#### 复制bootsect

bootsect将bootsect从BOOTSEG处移动到INITSEG处。为什么要复制自己（有病？）由于原来的“两头设计”，bootsect被迫的被放在BOOTSEG位置上，移动自己说明bootsect开始根据自身的需求安排内存。

复制代码如下
![2019-08-12-15-25-12.png](./images/2019-08-12-15-25-12.png)

* ds 和si构成源地址，es，di构成目的地址。cx存放256代表复制第一个扇区（256字，512字节）
* 此时的cs指向的是BOOTSEG，即原来的bootsect程序

复制代码完毕后就会执行下面代码
![2019-08-12-15-30-38.png](./images/2019-08-12-15-30-38.png)

* 这里主要是CS:IP跳转到INITSEG部分，这是程序已经完全脱离BIOS范畴了。


上面我们已经改变了CS地址，下面我们对DS、ES、SS、SP做调整，执行如下代码
![2019-08-12-15-59-51.png](./images/2019-08-12-15-59-51.png)

* cs值复制给 ds（数据段）、es（附加段寄存器）、ss（栈基址），SP指向偏移地址0xFF00.如图所示
    * 这里ss和sp初始化，说明下面可以对栈进行操作。栈的压栈是从高地址向低地址方向
![2019-08-12-16-03-33.png](./images/2019-08-12-16-03-33.png)


#### 将setup程序加载在内存中

* 加载setup程序，需要借助BIOS提供的int 0x13所指向的中断服务
* int0x13和int0x19不同，调用者是linux代码并且目的地址可指定不是固定的0x07C00
![2019-08-12-16-16-27.png](./images/2019-08-12-16-16-27.png)

## 3.1.3 加载第三部分内核代码--system
* 和加载setup程序一样，使用int0x13中断
* 这时操作系统任然没有运行，全都是汇编代码

## 3.1.4 再次确认下根设备号
* Linux 启动包含两个方面，一个是内核镜像，一个是根文件系统（这里的文件系统不是操作系统中文件系统代码，而是带有某种文件系统格式的设备）
* Linux使用Minix操作系统的文件管理方式，要求系统必须存在一个根文件系统，其它文件系统挂在在上面（不是同等地位）
![2019-08-12-16-28-53.png](./images/2019-08-12-16-28-53.png)

代码如下
![2019-08-12-16-31-21.png](./images/2019-08-12-16-31-21.png)

以上bootsect代码就执行完毕。

## 3.1.5 执行setup程序
接下来要跳转到SETUPSEG处，执行setup程序。

* setup 首先利用BIOS提供的中断服务获取内核运行所需的系统机器系统数据。为后面的main函数执行提供重要作用


以上内核加载基本结束
# 4. 开始想32位转变，为运行main函数做准备
* 这部分对Linux 操作系统有战略意义，系统通过已加载在内核中的代码，实现从实模式转变成保护模式。这部分使得Linux成为真正意义上的现代操作系统。

* 操作系统要使程序运行在32位保护模式下工作，这期间需要做大量重建工作。
    * 打开32位寻址空间
    * 打开保护模式
    * 建立保护模式下的中断响应机制
    * 做好保护模式响应的配套工作
    * 建立内存分页机制
    * 为调用面函数做准备


## 4.1 关中断，并将system移动到内存起始位置
* 首先关闭中断（EFLAGS中的中断标志位置0），这时不再对BIOS中断服务进行响应。
* 在下一章讲解的执行mian函数时才会重新打开中断进行响应，并且更牛逼的是这时候的中断服务已经换成了操作系统对应的中断服务（这时回答了我们啊Q1问题）
    


# Q&A
##Q1 中断服务程序如何统一
中断向量表和中断服务程序是由BIOS加载在操作系统中的。那么不同的BIOS就由不同的中断服务程序吗？Linux 调用中断都是通过中断信号来的，如果我的中断向量表因为中断信号由BIOS设计不同意或者中断服务程序不同意，那么程序调用不同的中断是否会返回不同的结果

启动操作系统过程中的中断服务确实是由BIOS提供的，但是等到操作系统运行之后，中断服务是由linux内核提供的。
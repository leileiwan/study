<!-- TOC -->

- [1. 通用寄存器](#1-通用寄存器)
    - [1.1 16位](#11-16位)
    - [1.2 32位](#12-32位)
- [2. 其它寄存器](#2-其它寄存器)
    - [2.1 CR0，CR1，CR2和CR3](#21-cr0cr1cr2和cr3)

<!-- /TOC -->
# 1. 通用寄存器
## 1.1 16位
* AX:累积暂存器
* BX:基底暂存器
* CX:计数暂存器
* DX:资料暂存器

* SI:来源索引暂存器
* DI:目的索引暂存器

* SP:堆叠指标暂存器
* BP:基底指标暂存器



## 1.2 32位

* EAX、ECX、EDX、EBX：為ax,bx,cx,dx的延伸，各為32位元
    * eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。

    * 比方说：add eax,-2 ; //可以认为是给变量eax加上-2这样的一个值。

* ESI、EDI、ESP、EBP：為si,di,sp,bp的延伸，32位元



* 这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。
    * EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。
    * EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。
    * ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。
    * EDX 则总是被用来放整数除法产生的余数。
    * ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.
    * EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码

# 2. 其它寄存器

* CS: 代码段基地址，存放在CPU中
* DS (Data Segment) 数据段
* ES (Extra Segment) 附加段
* SS (Stack Segment) 栈段 
* FS、GS 是从 80386 开始增加的，没有全称，取名就是按字母序排在 CS、DS、ES 之后的。在这之前只有一个辅助段寄存器ES,增加这两个寄存器是为了减轻ES寄存器的负担,并能更好地配合适用于通用寄存器组的基址和变址寄存器. (个人认为是从实模式下转向保护模式下段页寻址需要更多寄存器)。不能直接用立即数给它赋值。 

* IP/EIP: 指令指针寄存器，在CPU中，表示要执行指令在代码段中的偏移地址。CS:IP结合就是要执行指令地址。实模式下为绝对地址，16位（IP），实模式下为32叫做线性地址（EIP）

## 2.1 CR0，CR1，CR2和CR3
这几个寄存器中保存全局性和任务无关的机器状态。
* CR0
    * CR0中包含了6个预定义标志
    * 0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行
    * 1位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。
    * CR0的第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。
    * 第4位是微处理器的扩展类型位ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。
    * CR0的第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。

* CR1是未定义的控制寄存器，供将来的处理器使用。

* CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。

* CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。
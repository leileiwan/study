# systemd浅析

## 主要特点
1、强大的并行启动能力，极大的提高了系统开机启动速度。
2、使用Linux的CGroup来统计跟踪子进程，干净可靠。

## 如何管理子进程

init系统的重要特性是负责跟踪和管理服务进程的生命周期。

需求：
（1）服务通常在后台运行，进程派生时，如何找到真正的进程。
如下图，如果我们想kill掉p1进程，如果我们没有找到真正的p1进程，那么这个服务就失去控制。
![./images/1.png](6)

（2）删除父进程时，如果删掉所有的子进程
如果一个CGI程序派生两次，从而脱离了和Apache的斧子关系，若果我们kill掉Apache进程，CGI进程任然继续在运行。


Upstart 通过strace来跟踪fork和exit等系统调用，但是这种方法笨拙，缺乏课拓展性。
systemd利用Linux 内核CGroup特性来跟踪任务。当停止服务时，通过查询CGroup，systemd可以找到相关进程，从而干净的停止服务。

## 如何并行的启动程序

（1）sysVinit启动程序流程

![1.png](http://github.com/your_name/your_repository/raw/master/images_folder/1.png)
https://github.com/xiaoluwwwxiaolu/study/edit/master/systemd/systemd%E6%B5%85%E6%9E%90.md


（2）Upstart启动程序流程
![image.png](0)

（3）systemd启动程序流程
![image.png](5)

以上，我们可以看到，不管各个程序之间有没有依赖，systemd都支持并行启动。并且支持按需启动进程，不是像sysVinit一样默认启动所有程序。

并发启动关键是解决程序之间的依赖关系，systemd通过仔细研究服务之间相互依赖的本质问题，发现所谓的依赖分三种类型，每一种类型都可以通过相应的技术解除依赖关系。

### 并发系统原理之一：解决socket依赖
绝大多数服务都是套接字依赖。比如服务A通过套接字端口s1提供自己服务，其它服务需要服务A，则需要连接s1。若服务A尚未启动，s1就不存在，其它服务就会得到启动错误。
systemd认为，预先把s1创建好，那么其它所有服务就可以同时启动，而不需要等待A来创建s1。如果服务A尚未启动，那么其它进程向S1发送服务请求实际上会被Linux系统缓存，其它进程会在这个请求的地方等待，一旦A启动就绪，就可以立即处理缓存请求。
那么服务如何使用由Init进程创建的套接字呢？
Linux通过调用fork和exec创建子进程后，所有父进程中打开的文件句柄都被子进程继承，子进程看到的套接字就好像是自己创建的套接字一样，没有任何区别。
Linux的这种特性被一个叫inetd的系统调用利用，Initd负责监控一些常用的套接字端口，比如telnetd，比如当telnet有请求时，initd才启动telnetd进程，并把连接的套接字传递给新的telnetd进程进行处理。
和initd类似，systemd是所有进程的父进程，他可以创建所需要的套接字，然后调用exec的时候将套接字传递给新的进程服务。

### 并发启动原理之二：解决D-Bus 依赖
D-Bus是desktop-bus的简称，是一个低延时、低开销、高可用性的进程通信机制，很多服务进程通信都使用D-Bus取代套接字作为进程通信。

D-Bus支持所谓“bus activation”功能。当A需要服务B的D-Bus服务时，但B没有运行，D-Bus可以在A请求B时创建B服务。服务A的请求会被D-Bus缓存，服务A等待服务B就绪。

### 并发启动原理三：解决文件系统依赖
系统启动过程中，文件相关活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查，磁盘配额检查等都是相当耗时的。
SYstemd参考autofs设计思路，使得依赖文件系统的服务和文件系统本身的初始化是可以并行操作的。autofs可以监测到某个文件系统挂载点真正被访问时才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open()系统调用作用在"/misc/cd/file1"的时候，/misc/cd 尚未执行挂载操作，此时 open()调用被挂起等待，Linux 内核通知 autofs，autofs 执行挂载。这时候，控制权返回给 open()系统调用，并正常打开文件。
Systemd 集成了 autofs 的实现，对于系统中的挂载点，比如/home，当系统启动的时候，systemd 为其创建一个临时的自动挂载点。在这个时刻/home 真正的挂载设备尚未启动好，真正的挂载操作还没有执行，文件系统检测也还没有完成。可是那些依赖该目录的进程已经可以并发启动，他们的 open()操作被内建在 systemd 中的 autofs 捕获，将该 open()调用挂起（可中断睡眠状态）。然后等待真正的挂载操作完成，文件系统检测也完成后，systemd 将该自动挂载点替换为真正的挂载点，并让 open()调用返回。由此，实现了那些依赖于文件系统的服务和文件系统本身同时并发启动。

当然对于"/"根目录的依赖实际上一定还是要串行执行，因为 systemd 自己也存放在/之下，必须等待系统根目录挂载检查好。


<!-- TOC -->

- [1. x86历史](#1-x86历史)
    - [1.1 x86发展历史](#11-x86发展历史)
    - [1.2 x86_64](#12-x86_64)
        - [1.2.1 AMD64](#121-amd64)
        - [1.2.2 Intel 64](#122-intel-64)
- [2. x86 内存架构](#2-x86-内存架构)
    - [2.1 地址空间](#21-地址空间)
        - [2.1.1 物理地址空间](#211-物理地址空间)
        - [2.1.2 线性地址空间](#212-线性地址空间)
    - [2.2 地址](#22-地址)
        - [2.2.1 逻辑地址](#221-逻辑地址)
        - [2.2.2 线性地址](#222-线性地址)
        - [2.2.3 物理地址](#223-物理地址)
    - [2.3 x86 内存管理机制](#23-x86-内存管理机制)
        - [2.3.1 分段机制](#231-分段机制)
            - [2.3.1.1 段选择符（段选择寄存器）](#2311-段选择符段选择寄存器)

<!-- /TOC -->
# 1. x86历史
## 1.1 x86发展历史
如图1-1所示x86的发展历程:
![2019-09-23-16-03-54.png](./images/2019-09-23-16-03-54.png)

* 1978年，最早的x86处理器8086初次登场。8086是16位的处理器，这个位数指的是CPU GPR（General-Purpose Register，通用寄存器）的数据宽度为16位。8086处理器拥有16位的寄存器和16位的外部数据总线，使用20位地址寻址（拥有1MB的地址空间）。
* 在20世纪80年代初，IBM选择了8086的衍生产品8088作为IBM PC的处理器。IBM的这一举动给x86带来了巨大的发展机遇，并且帮助它成为行业的标准直到今天。
* 1982年, Intel发布80286处理器, 引入了保护模式的概念.
* 1985年后, Intel公司发布了x86体系结构下的第一款32位处理器80386, 并且引入虚拟内存.
* 1989年, 80486发布, 采用了5级流水线机制, 并且引入了片上一级缓存和能量管理.

* 当时数字不能作为商标, 1993年, Intel公司发布第一款奔腾处理器(Pentium), 此款处理器在80486基础上, 进一步增大一级缓存, 并将其分成指令缓存和数据缓存两部分, 进一步加快处理器对主存的访问时间. 同时, 奔腾处理器还引入了MMX技术, 使得处理器对多媒体处理的支持进一步增强.

* 1995到1999年, Intel发布一系列基于x86体系结构的处理器, 这一系列被称为P6家族处理器, 包括奔腾Pro(Pentium Pro), 奔腾2(Pentium Ⅱ), 奔腾2至强(Pentium Ⅱ Xeon), 赛扬(Celeron), 奔腾3(Pentium Ⅲ)以及奔腾3至强(Pentium Ⅲ Xeon)处理器. P6家族采用了超标量(Superscalar)技术, 以乱序执行的方式进一步增强了处理器的速度.

* 从2002年开始到2006年, 奔腾4(Pentium 4)家族处理器(！！！一系列！！！)占据了主导地位. 奔腾4家族的处理器基于NetBurst微处理结构, 在提升性能同时, 进一步增强了对多媒体处理的支持, 并引入超线程的概念(Hyper-Threading), 引领单核处理器的性能走向极致. 与此同时, 在奔腾4的672和662处理器上， Intel还首次加入了虚拟化支持, 即Intel VT技术. 也是在这段时期，由于AMD发展的64位扩充技术的刺激，Intel公司开始推出64位版x86。

* 从2006年起, 处理器进入多核时代(Multicore), Intel相继发布Core Duo和Core 2 Duo系列处理器.

## 1.2 x86_64
x86-64 是 x86 架构的延伸产品，是一种 64 位微处理器架构及其相应的指令集。 在x86-64出现以前，Intel与惠普联合推出IA-64架构，此架构不与x86兼容，且市场反应冷淡。于是，与 x86 兼容的 x86-64 架构应运而生。1999 年， AMD首次公开64位集为IA-32提供扩展，称为x86-64（后来改名为AMD64）。此架构后来也为Intel所采用，也就是现在的Intel 64。

x86-64能有效地把 x86架构移植到 64位环境，并且兼容原有的 x86应用程序，市场前景广阔。外界使用x84-64或者x64称呼这个64位架构，以保持中立，不偏袒任何一家厂商。

### 1.2.1 AMD64
AMD 64指令集被应用在Athlon 64、Athlon 64 FX、Athlon 64 X2、Turion 64、Turion 64 X2、Opteron及较新款的Sempron和Phenom处理器上。

其主要特点有：支持64位通用寄存器、64位整数及逻辑运算和64位虚拟地址。AMD 64架构相比之前的32位架构有如下重大改进。
* 新增寄存器。
* 地址宽度加长。
* 新增扩充指令集SSE2、SSE3。
* 新增“禁止运行”位（No-Execute，NX bit）：此位的设置可以防止蠕虫病毒的缓存溢出攻击。

### 1.2.2 Intel 64
Intel 64指令集被应用于Pentium 4、Pentium D、Pentium Extreme Edition、Celeron D、Xeon、Intel Core 2、Intel Core 2 Quad、Intel Core i3、Intel Core i5及Intel Core i7处理器上。

Intel 64架构加入了额外的寄存器和其他改良的指令集，可使处理器直接访问超过4GB的存储器，允许运行更大的应用程序。通过64位的存储器地址上限，其理论存储器容量上限达16 000 000TB（16EB），但大多数操作系统和应用程序在可见的未来都用不到如此巨大的地址空间，在初期的应用上并未支持完整的64位地址。Intel 64架构相比之前的32位架构有如下重大改进。

* 新增寄存器。
* 地址宽度加长。
* 新增改良指令集。
* 新增“禁止运行”位（eXecute Disable，XD bit）：相当于AMD 64的NX bit，通过设置此位可以防止蠕虫病毒的缓存溢出攻击。

# 2. x86 内存架构
## 2.1 地址空间
### 2.1.1 物理地址空间
*  从CPU的角度来看, 内存和其它硬件设备都是可以使用的资源. 这些资源组合(！！！)在一起, 分布在CPU的物理地址空间内(！！！内存只是一部分！！！).
* 物理地址空间的大小, 由CPU实现的物理地址位数决定, 物理地址位数和CPU处理数据的能力(即CPU位数)没有必然关系, 例如16位的8086 CPU具有20位地址空间.


### 2.1.2 线性地址空间
* 和物理地址空间一样, 线性地址空间大小取决于CPU实现的线性地址位数, 例如实现了32位线性地址的CPU具有4GB大小的线性地址空间. 
* 需要注意, 线性地址空间大小和物理地址空间大小没有必然关系. 例如Intel的PAE平台就具有4GB的线性地址空间, 64GB的物理地址空间.
* 一个平台可以有多个线性地址空间, 在现代操作系统中, 每个进程都拥有自己的私有线性地址空间. 一个典型的线性地址空间如图.
![2019-09-24-15-41-47.png](./images/2019-09-24-15-41-47.png)

## 2.2 地址
### 2.2.1 逻辑地址
* 程序代码中使用的地址就是逻辑地址，逻辑地址通常由段选择符和段偏移地址组成，程序中操作的地址是段偏移地址部分。

### 2.2.2 线性地址
* 线性地址又叫虚拟地址，线性地址是逻辑地址转化之后结构，用来索引线性地址空间。当CPU采用分页机制时，线性地址必须转化成物理地址才能访问平台内存和硬件设备。
* 如果地址没有采用分页，线性地址就是物理地址

### 2.2.3 物理地址
* 未采用分段机制:逻辑地址->线性地址=物理地址
* 采用分段机制: 逻辑地址->线性地址->物理地址

有些资料还有"总线地址"的提法, 因为给设备寄存器分配的物理地址(！！！)和寄存器在设备上的地址(！！！)是不同的(通常设备的寄存器都认为自己是从地址0开始的), 两者存在一个映射关系, 由设备的电子线路负责转换并对CPU透明(！！！). 由于CPU用于访问设备的物理地址(！！！)是设备寄存器展现给总线的地址, 所以在x86下有时称物理地址为总线地址.


## 2.3 x86 内存管理机制
* x86 内存管理机制分为两部分：分段机制和分页机制。
* 分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。

* 分页机制实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。

* 分段机制和分页机制都可以通过配置支持简单的单任务系统、多任务系统或共享内存的多处理器系统。需要强调的一点是，处理器无论在何种运行模式下都不可以禁止分段机制，但是分页机制却是可选选项。

### 2.3.1 分段机制
分段是一种简单的内存管理机制, 它将内存划分成以起始地址(Base)和长度(Limit)描述的块, 这些内存块就称为"段". 段可以与程序最基本的元素联系起来, 例如程序可以简单的分为代码段、数据段和栈, 段机制中就有对应的代码段、数据段和栈段。

分段机制由4个基本部分组成: 逻辑地址、段选择寄存器、段描述符和段描述符表。
其核心思想是: 使用段描述符描述段的基地址、长度以及各种属性(例如读写属性、访问权限). 当程序使用逻辑地址访问内存的某个部分时, CPU通过逻辑地址中的段选择符索引段描述符表以得到该内存对应的段描述符, 并检测程序的访问是否合法, 合法的话, 根据段描述符中的基地址将逻辑地址转换为线性地址.
* 逻辑地址：程序使用地址
* 段描述符表：用来索引每个程序的段描述地址
* 段描述符：存储每个进程段首地址和属性等重要内容
* 段选择寄存器：存储段描述符表的偏移地址，指向的每个进程的段描述符地址

![2019-09-24-16-20-32.png](./images/2019-09-24-16-20-32.png)

#### 2.3.1.1 段选择符（段选择寄存器）
段描述符用来索引段描述符，段描述符存储在段选择寄存器中。
段描述符共16位，结构图如下：
![2019-09-24-16-28-28.png](./images/2019-09-24-16-28-28.png)

各个字段含义如下：
* 索引：段描述符表索引
* TI：指明索引哪个段描述符表。当 TI=0 时，表示索引全局段描述符表（Global Descriptor Table，下面简称为GDT）；当TI=1时，表示索引本地段描述符表（Local Descriptor Table，下面简称为LDT）
* RPL：Requested Privilege Level的简称，即所要求的权限级别。RPL存在于段选择寄存器的0、1位，为程序访问段时增加一级检查。

段选择符作为逻辑地址的一部分，对应用程序是可见的。但是，正如前面在逻辑地址中介绍的，应用程序中只存储和使用逻辑地址的偏移部分，段描述符！！！ 的修改和分配！！！ 由连接器和加载器！！！ 完成。

为了使CPU能够快速地获得段选择符，x86架构提供了6个段寄存器存放当前程序中各个段的段选择符。这6个段寄存器分别如下。

* CS（Code-Segment，代码段）：存放代码段的段选择符。
* DS（Data-Segment，数据段）：存放数据段的段选择符。
* SS（Stack-Segment，栈段）：存放栈的段选择符。
* ES、FS、GS：可以存放额外三个数据段的段选择符，由程序自由使用。



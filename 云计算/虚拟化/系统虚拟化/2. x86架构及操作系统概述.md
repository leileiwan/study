<!-- TOC -->

- [1. x86历史](#1-x86历史)
    - [1.1 x86发展历史](#11-x86发展历史)
    - [1.2 x86_64](#12-x86_64)
        - [1.2.1 AMD64](#121-amd64)
        - [1.2.2 Intel 64](#122-intel-64)
- [2. x86 内存架构](#2-x86-内存架构)
    - [2.1 地址空间](#21-地址空间)
        - [2.1.1 物理地址空间](#211-物理地址空间)
        - [2.1.2 线性地址空间](#212-线性地址空间)
    - [2.2 地址](#22-地址)
        - [2.2.1 逻辑地址](#221-逻辑地址)
        - [2.2.2 线性地址](#222-线性地址)
        - [2.2.3 物理地址](#223-物理地址)
    - [2.3 x86 内存管理机制](#23-x86-内存管理机制)
        - [2.3.1 分段机制](#231-分段机制)
            - [2.3.1.1 段选择符（段选择寄存器）](#2311-段选择符段选择寄存器)
            - [2.3.1.2 段描述符](#2312-段描述符)
            - [2.3.1.3 段描述符表](#2313-段描述符表)
            - [2.3.1.4 逻辑地址转换总结](#2314-逻辑地址转换总结)
        - [2.3.2 分页机制](#232-分页机制)
            - [页表](#页表)

<!-- /TOC -->
# 1. x86历史
## 1.1 x86发展历史
如图1-1所示x86的发展历程:
![2019-09-23-16-03-54.png](./images/2019-09-23-16-03-54.png)

* 1978年，最早的x86处理器8086初次登场。8086是16位的处理器，这个位数指的是CPU GPR（General-Purpose Register，通用寄存器）的数据宽度为16位。8086处理器拥有16位的寄存器和16位的外部数据总线，使用20位地址寻址（拥有1MB的地址空间）。
* 在20世纪80年代初，IBM选择了8086的衍生产品8088作为IBM PC的处理器。IBM的这一举动给x86带来了巨大的发展机遇，并且帮助它成为行业的标准直到今天。
* 1982年, Intel发布80286处理器, 引入了保护模式的概念.
* 1985年后, Intel公司发布了x86体系结构下的第一款32位处理器80386, 并且引入虚拟内存.
* 1989年, 80486发布, 采用了5级流水线机制, 并且引入了片上一级缓存和能量管理.

* 当时数字不能作为商标, 1993年, Intel公司发布第一款奔腾处理器(Pentium), 此款处理器在80486基础上, 进一步增大一级缓存, 并将其分成指令缓存和数据缓存两部分, 进一步加快处理器对主存的访问时间. 同时, 奔腾处理器还引入了MMX技术, 使得处理器对多媒体处理的支持进一步增强.

* 1995到1999年, Intel发布一系列基于x86体系结构的处理器, 这一系列被称为P6家族处理器, 包括奔腾Pro(Pentium Pro), 奔腾2(Pentium Ⅱ), 奔腾2至强(Pentium Ⅱ Xeon), 赛扬(Celeron), 奔腾3(Pentium Ⅲ)以及奔腾3至强(Pentium Ⅲ Xeon)处理器. P6家族采用了超标量(Superscalar)技术, 以乱序执行的方式进一步增强了处理器的速度.

* 从2002年开始到2006年, 奔腾4(Pentium 4)家族处理器(！！！一系列！！！)占据了主导地位. 奔腾4家族的处理器基于NetBurst微处理结构, 在提升性能同时, 进一步增强了对多媒体处理的支持, 并引入超线程的概念(Hyper-Threading), 引领单核处理器的性能走向极致. 与此同时, 在奔腾4的672和662处理器上， Intel还首次加入了虚拟化支持, 即Intel VT技术. 也是在这段时期，由于AMD发展的64位扩充技术的刺激，Intel公司开始推出64位版x86。

* 从2006年起, 处理器进入多核时代(Multicore), Intel相继发布Core Duo和Core 2 Duo系列处理器.

## 1.2 x86_64
x86-64 是 x86 架构的延伸产品，是一种 64 位微处理器架构及其相应的指令集。 在x86-64出现以前，Intel与惠普联合推出IA-64架构，此架构不与x86兼容，且市场反应冷淡。于是，与 x86 兼容的 x86-64 架构应运而生。1999 年， AMD首次公开64位集为IA-32提供扩展，称为x86-64（后来改名为AMD64）。此架构后来也为Intel所采用，也就是现在的Intel 64。

x86-64能有效地把 x86架构移植到 64位环境，并且兼容原有的 x86应用程序，市场前景广阔。外界使用x84-64或者x64称呼这个64位架构，以保持中立，不偏袒任何一家厂商。

### 1.2.1 AMD64
AMD 64指令集被应用在Athlon 64、Athlon 64 FX、Athlon 64 X2、Turion 64、Turion 64 X2、Opteron及较新款的Sempron和Phenom处理器上。

其主要特点有：支持64位通用寄存器、64位整数及逻辑运算和64位虚拟地址。AMD 64架构相比之前的32位架构有如下重大改进。
* 新增寄存器。
* 地址宽度加长。
* 新增扩充指令集SSE2、SSE3。
* 新增“禁止运行”位（No-Execute，NX bit）：此位的设置可以防止蠕虫病毒的缓存溢出攻击。

### 1.2.2 Intel 64
Intel 64指令集被应用于Pentium 4、Pentium D、Pentium Extreme Edition、Celeron D、Xeon、Intel Core 2、Intel Core 2 Quad、Intel Core i3、Intel Core i5及Intel Core i7处理器上。

Intel 64架构加入了额外的寄存器和其他改良的指令集，可使处理器直接访问超过4GB的存储器，允许运行更大的应用程序。通过64位的存储器地址上限，其理论存储器容量上限达16 000 000TB（16EB），但大多数操作系统和应用程序在可见的未来都用不到如此巨大的地址空间，在初期的应用上并未支持完整的64位地址。Intel 64架构相比之前的32位架构有如下重大改进。

* 新增寄存器。
* 地址宽度加长。
* 新增改良指令集。
* 新增“禁止运行”位（eXecute Disable，XD bit）：相当于AMD 64的NX bit，通过设置此位可以防止蠕虫病毒的缓存溢出攻击。

# 2. x86 内存架构
## 2.1 地址空间
### 2.1.1 物理地址空间
*  从CPU的角度来看, 内存和其它硬件设备都是可以使用的资源. 这些资源组合(！！！)在一起, 分布在CPU的物理地址空间内(！！！内存只是一部分！！！).
* 物理地址空间的大小, 由CPU实现的物理地址位数决定, 物理地址位数和CPU处理数据的能力(即CPU位数)没有必然关系, 例如16位的8086 CPU具有20位地址空间.


### 2.1.2 线性地址空间
* 和物理地址空间一样, 线性地址空间大小取决于CPU实现的线性地址位数, 例如实现了32位线性地址的CPU具有4GB大小的线性地址空间. 
* 需要注意, 线性地址空间大小和物理地址空间大小没有必然关系. 例如Intel的PAE平台就具有4GB的线性地址空间, 64GB的物理地址空间.
* 一个平台可以有多个线性地址空间, 在现代操作系统中, 每个进程都拥有自己的私有线性地址空间. 一个典型的线性地址空间如图.
![2019-09-24-15-41-47.png](./images/2019-09-24-15-41-47.png)

## 2.2 地址
### 2.2.1 逻辑地址
* 程序代码中使用的地址就是逻辑地址，逻辑地址通常由段选择符和段偏移地址组成，程序中操作的地址是段偏移地址部分。

### 2.2.2 线性地址
* 线性地址又叫虚拟地址，线性地址是逻辑地址转化之后结构，用来索引线性地址空间。当CPU采用分页机制时，线性地址必须转化成物理地址才能访问平台内存和硬件设备。
* 如果地址没有采用分页，线性地址就是物理地址

### 2.2.3 物理地址
* 未采用分段机制:逻辑地址->线性地址=物理地址
* 采用分段机制: 逻辑地址->线性地址->物理地址

有些资料还有"总线地址"的提法, 因为给设备寄存器分配的物理地址(！！！)和寄存器在设备上的地址(！！！)是不同的(通常设备的寄存器都认为自己是从地址0开始的), 两者存在一个映射关系, 由设备的电子线路负责转换并对CPU透明(！！！). 由于CPU用于访问设备的物理地址(！！！)是设备寄存器展现给总线的地址, 所以在x86下有时称物理地址为总线地址.


## 2.3 x86 内存管理机制
* x86 内存管理机制分为两部分：分段机制和分页机制。
* 分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。

* 分页机制实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。

* 分段机制和分页机制都可以通过配置支持简单的单任务系统、多任务系统或共享内存的多处理器系统。需要强调的一点是，处理器无论在何种运行模式下都不可以禁止分段机制，但是分页机制却是可选选项。

### 2.3.1 分段机制
分段是一种简单的内存管理机制, 它将内存划分成以起始地址(Base)和长度(Limit)描述的块, 这些内存块就称为"段". 段可以与程序最基本的元素联系起来, 例如程序可以简单的分为代码段、数据段和栈, 段机制中就有对应的代码段、数据段和栈段。

分段机制由4个基本部分组成: 逻辑地址、段选择寄存器、段描述符和段描述符表。
其核心思想是: 使用段描述符描述段的基地址、长度以及各种属性(例如读写属性、访问权限). 当程序使用逻辑地址访问内存的某个部分时, CPU通过逻辑地址中的段选择符索引段描述符表以得到该内存对应的段描述符, 并检测程序的访问是否合法, 合法的话, 根据段描述符中的基地址将逻辑地址转换为线性地址.
* 逻辑地址：程序使用地址
* 段描述符表：用来索引每个程序的段描述地址
* 段描述符：存储每个进程段首地址和属性等重要内容
* 段选择寄存器：存储段描述符表的偏移地址，指向的每个进程的段描述符地址

![2019-09-24-16-20-32.png](./images/2019-09-24-16-20-32.png)

#### 2.3.1.1 段选择符（段选择寄存器）
段描述符用来索引段描述符，段描述符存储在段选择寄存器中。
段描述符共16位，结构图如下：
![2019-09-24-16-28-28.png](./images/2019-09-24-16-28-28.png)

各个字段含义如下：
* 索引：段描述符表索引
* TI：指明索引哪个段描述符表。当 TI=0 时，表示索引全局段描述符表（Global Descriptor Table，下面简称为GDT）；当TI=1时，表示索引本地段描述符表（Local Descriptor Table，下面简称为LDT）
* RPL：Requested Privilege Level的简称，即所要求的权限级别。RPL存在于段选择寄存器的0、1位，为程序访问段时增加一级检查。

段选择符作为逻辑地址的一部分，对应用程序是可见的。但是，正如前面在逻辑地址中介绍的，应用程序中只存储和使用逻辑地址的偏移部分，段描述符！！！ 的修改和分配！！！ 由连接器和加载器！！！ 完成。

为了使CPU能够快速地获得段选择符，x86架构提供了6个段寄存器存放当前程序中各个段的段选择符。这6个段寄存器分别如下。

* CS（Code-Segment，代码段）：存放代码段的段选择符。
* DS（Data-Segment，数据段）：存放数据段的段选择符。
* SS（Stack-Segment，栈段）：存放栈的段选择符。
* ES、FS、GS：可以存放额外三个数据段的段选择符，由程序自由使用。

由于段选择符是用来索引段描述符表访问段描述符的，为了加速段描述符的访问，x86 在段寄存器后增加了一个程序不可见的段描述符寄存器。当段寄存器被加载到一个新的段选择符后，CPU自动将该段选择符索引的段描述符加载到这个不可见的段描述符寄存器中。这6个段寄存器的构造如图1-5所示。 ￼ 图1-5 段寄存器的构造:
![2019-09-24-16-34-06.png](./images/2019-09-24-16-34-06.png)


#### 2.3.1.2 段描述符
段描述符描述某个段的基地址、长度以及各种属性（例如，读/写属性、访问权限等）。这是分段机制的核心思想。

段描述符的结构如图1-6所示。
![2019-09-24-16-48-39.png](./images/2019-09-24-16-48-39.png)
在此，我们只详细介绍其中的Base字段、Limit字段和DPL字段。

* Base字段描述了该段的基地址。
* Limit字段描述了该段的长度。
* DPL字段指明描述符权限级别，表示该段所具有的权限。它表示代码访问此段所需要的最低权限！！！。

当CPU通过一个逻辑地址的段选择符获得该段对应的段描述符后，会使用段描述符中各种属性字段对访问进行检查，一旦确认访问合法，CPU将段描述符中的32位基地址和程序中逻辑地址的32位偏移量相加。至此，CPU便获得了逻辑地址所对应的线性地址。

#### 2.3.1.3 段描述符表
在前面介绍段选择符的结构时，我们了解到段选择符中的 TI 字段用于指明索引哪个段描述符表。TI字段的必要性源于x86架构提供了两种段描述符表 — GDT和LDT。
系统中至少有一个 GDT 可以被所有的进程访问。与此同时，系统中可以有一个或多个LDT，可以被某个进程私有，也可以被多个进程共享。

* GDT是内存中的一个数据结构。简单地讲，可以将GDT看成是一个数组，由基地址（Base）和长度（Limit）描述。
* LDT是一个段，需要用一个段描述符来描述。LDT 的段描述符存放在GDT中，当系统中有多个LDT时，GDT中必须有对应数量的段描述符。

为了加速对GDT和LDT的访问，x86架构提供了GDTR寄存器和LDTR寄存器。关于这两种寄存器的具体描述如下。

* GDTR：包括一个32位的基地址（Base）和一个16位的长度（Limit）。
* LDTR：结构与段寄存器相同（同样包含对程序不可见的段描述符寄存器）。
通过使用LGDT/SGDT指令对GDTR进行读取/存储；
通过使用LLDT/SLDT对LDTR进行读取/存储。
在进行进程切换时，LDTR的值会被换成新进程对应的LDT的段描述符。
通过段选择符索引GDT/LDT的过程如图1-7所示。
![2019-09-24-16-54-59.png](./images/2019-09-24-16-54-59.png)

#### 2.3.1.4 逻辑地址转换总结
假设程序中某条语句访问了数据段, 例如:
```
int a = 100; //全局变量
int func(){
    int b;
    b = a;
}
```
程序从加载到变量a的逻辑地址转换为线性地址过程如下.
* 程序加载
    * 通过该进程LDT的段选择符！！！索引GDT, 获得LDT的段描述符, 被加载到LDTR寄存器的不可见部分中.
    * 该进程的CS、DS、SS被加载到了相应的段选择符. 同时, CPU根据段选择符的TI字段, 索引GDT/LDT, 获得相应的段描述符并加载到CS、DS、SS对应的不可见部分.
* 程序执行到b=a, 需要从a所在的内存中取值, 必须先把a的逻辑地址转换成线性地址
    *  进行必要的属性、访问权限检查
    * 从DS对应的段描述符寄存器获得该段的基地址
    * 将变量a的32位偏移量和描述符中的基地址相加, 获得变量a的线性地址.


### 2.3.2 分页机制
分页机制让操作系统中的虚拟内存机制称为可能. 一个页面可以存在于物理内存(！！！)中, 也可以存放在磁盘的交换区域！！！(如Linux下的Swap分区！！！, Windows的虚拟内存文件！！！)中, 程序可以使用比机器物理内存更大的内存区域！！！.

分页机制的核心思想是通过页表将线性地址转换为物理地址, 并配合旁路转换缓冲区(Translation Lookaside Buffer, TLB！！！)来加速地址转换过程. 操作系统在启动过程中, 通过将CR0寄存器的PG位置1来启动分页机制.
![2019-09-24-17-02-24.png](./images/2019-09-24-17-02-24.png)
从图中看到, 分页机制主要由页表、CR3和TLB三个部件构成. 下面以4KB页面的32位分页为例进行讲解.

#### 页表







<!-- TOC -->

- [1. 虚拟化技术背景](#1-虚拟化技术背景)
    - [1.1 特权指令和敏感指令](#11-特权指令和敏感指令)
    - [1.2 虚拟环境的简单实现](#12-虚拟环境的简单实现)
    - [1.3  虚拟化漏洞的产生](#13--虚拟化漏洞的产生)
    - [1.4 虚拟化漏洞的解决办法](#14-虚拟化漏洞的解决办法)
- [2. 处理器虚拟化](#2-处理器虚拟化)
    - [2.1 指令模拟](#21-指令模拟)
        - [2.1.1 虚拟寄存器](#211-虚拟寄存器)
        - [2.1.2 上下文](#212-上下文)
        - [2.1.3 虚拟处理器](#213-虚拟处理器)
            - [2.1.3.1 客户机OS角度的虚拟处理器](#2131-客户机os角度的虚拟处理器)
            - [2.1.3.2 VMM角度的虚拟处理器](#2132-vmm角度的虚拟处理器)

<!-- /TOC -->

# 1. 虚拟化技术背景
## 1.1 特权指令和敏感指令
* 多数现代计算机体系结构都有两个或以上的特权级, 用来分隔系统软件和应用软件.
* 系统中一些操作和管理关键系统资源的指令会被定为特权指令, 这些指令只有在最高特权级上正确执行(！！！不是说只能在最高级别运行！！！). 在非最高特权级上, 特权指令会引发一个异常, 处理器会陷入最高特权级, 交给系统软件来处理.
* 在不同的运行级上, 不仅指令的执行效果是不同的, 而且不是！！！所有特权指令都会发生异常(！！！). 例如一个x86平台的用户违反规范, 在用户态修改EFLAGS寄存器的中断位, 这一修改不会产生任何效果, 也不会引起异常陷入, 而是会被硬件直接忽略.
* 在虚拟化里, 还有一类指令被称为敏感指令, 即操作特权资源的指令, 包括修改虚拟机的运行模式或下面物理机的状态; 读写敏感的寄存器或内存, 例如时钟或中断寄存器; 访问存储保护系统、内存系统或地址重定位系统以及所有的I/O指令.
* 显然, 所有特权指令！！！都是敏感指令！！！, 然而并不是所有敏感指令！！！都是特权指令！！！. 
## 1.2 虚拟环境的简单实现
为VMM可以完全控制系统资源, 不允许直接执行客户机操作系统的敏感指令(！！！包括了特权指令和敏感指令！！！）. 即, 敏感指令！！！必须在VMM的监控审查下进行！！！, 或经由VMM来完成.

如果一个系统上所有敏感指令都是特权指令！！！, 则能用一个很简单的方法实现一个虚拟环境: 将VMM运行在最高特权级, 客户机OS运行在非最高特权级上, 当客户机OS因执行敏感指令(此时, 也是特权指令)而陷入到VMM时, VMM模拟执行引起异常的敏感指令！！！, 这种方法叫"陷入再模拟".

## 1.3  虚拟化漏洞的产生
总之, 判断一个结构是否可以虚拟化, 其核心在于该结构对敏感指令的支持上. 如果在某些结构上所有敏感指令都是特权指令！！！, 则它是可虚拟化的结构; 否则, 如果它无法支持在所有敏感指令！！！上触发异常, 则不是一个可虚拟化的结构, 我们称存在"虚拟化漏洞".

总之, 判断一个结构是否可以虚拟化, 其核心在于该结构对敏感指令的支持上. 如果在某些结构上所有敏感指令都是特权指令！！！, 则它是可虚拟化的结构; 否则, 如果它无法支持在所有敏感指令！！！上触发异常, 则不是一个可虚拟化的结构, 我们称存在"虚拟化漏洞".

## 1.4 虚拟化漏洞的解决办法
* 所有指令解释执行. 最简单最直接的方法是, 如果所有虚拟化都采用模拟来实现(！！！), 例如解释执行, 就是取一条指令, 模拟出这条指令执行的效果, 再继续取下一条指令(！！！所有指令, 无论是否敏感指令！！！), 那么就不存在所谓陷入不陷入的问题, 从而避免了虚拟化漏洞. 这种方法不但能适用于模拟与物理机相同体系结构的虚拟机, 而且也能模拟不同体系结构的虚拟机. 这种方法保证了所有指令执行收到VMM的监管, 但它对每条指令不区别对待, 最大缺点是性能太差, 不符合虚拟机"高效"特点.

* 硬件辅助手段. 既要填补虚拟化漏洞, 又要保证虚拟化性能, 只能采取一些辅助手段, 或直接在硬件层面填补虚拟化漏洞！！！,

* 软件辅助避免使用无法陷入的敏感指令. 或通过软件的方法避免虚拟机中使用无法陷入的敏感指令！！！.


# 2. 处理器虚拟化
处理器虚拟化是VMM中最核心的部分, 因为访问内存和I/O指令本身就是敏感指令, 所以内存虚拟化和I/O虚拟化都依赖于处理器虚拟化的正确实现.


## 2.1 指令模拟

VMM运行在最高特权级, 可以控制物理处理器上所有关键资源; 客户机OS运行在非最高特权级, 所以其敏感指令会陷入到VMM中通过软件方式进行模拟. 所以, 处理器虚拟化的关键在于正确模拟指令的行为.

介绍指令模拟之前, 我们理解三个概念: 虚拟寄存器、上下文和虚拟处理器.

### 2.1.1 虚拟寄存器
从某种程度上, 物理处理器无非包括了一些存放数据的物理寄存器, 并且规定了使用这些寄存器的指令集, 然后按照一段预先写好的指令流, 在给定的时间点使用给定的部分寄存器来完成某种目的.

当客户机OS试图访问关键资源！！！的时候, 该请求并不会真正发生在物理寄存器上. 相反, VMM会通过准确模拟物理处理器的行为, 而将其访问定位到VMM为其设计与物理寄存器对应的"虚拟"的寄存器上.

当然, 从VMM实现来说, 这样的虚拟寄存器往往是在内存中！！！.
![2019-09-26-11-22-25.png](./images/2019-09-26-11-22-25.png)

### 2.1.2 上下文
在没有虚拟化的环境中, 操作系统直接负责物理处理器管理, 负责进程间调度和切换. 但是, VMM接管物理处理器后, 客户机OS运行在VMM为之设计的虚拟处理器之上, 管理虚拟处理器, 并在虚拟处理器上负责该虚拟机内进程调度和切换. 而调度切换, 涉及到了上下文状态, 这里是虚拟处理器上下文.

而在某个时刻, 物理处理器中的寄存器状态构成了当前进程的上下文状态.

进程上下文！！！主要是与运算相关的寄存器状态！！！, 例如EIP寄存器指向进程当前执行的指令, ESP存放着当前进程的堆栈指针等.

虚拟处理器上下文比进程上下文更为复杂, 因为客户机OS本身包含很多敏感指令, 会试图访问和修改物理处理器上定义的所有寄存器, 而这种访问和修改会被VMM重定位到虚拟处理器上. 所以, 对于虚拟处理器, 其上下文包括了更多的系统寄存器, 例如CR0、CR3、CR4和各种MSR等. 当VMM在决定切换虚拟处理器的时候, 需要考虑保存和恢复的上下文也更为复杂.（包含了很多操作系统中很多不可见寄存器）


### 2.1.3 虚拟处理器
虚拟处理器可以从两个角度来理解.
#### 2.1.3.1 客户机OS角度的虚拟处理器
首先, 从客户机OS角度, 其在运行的虚拟处理器需要具备与其"期望"的物理处理器一样的功能和行为, 这种"期望"的前提条件甚至可以允许客户机OS的修改, 例如VMM可以修改客户机OS的源码, 使客户机OS所"期望"的与VMM所呈现的功能集合一致. 典型"期望"包括:

⓵ 指令集合与执行效果

⓶ 可用寄存器集合, 包括通用寄存器以及各种系统寄存器.

⓷ 运行模式, 例如实模式、保护模式和64位长模式等。 处理器的运行模式决定了指令执行的效果、寻址宽度和限制以及保护粒度等.

⓸ 地址翻译系统, 例如页表级数.

⓹ 保护机制, 例如分页和分段等.

⓺ 中断/异常机制, 例如虚拟处理器必须能够正确模拟真实处理器的行为, 在错误的执行条件下, 为虚拟机注入一个虚拟的异常.

#### 2.1.3.2 VMM角度的虚拟处理器
从VMM的角度看, 虚拟处理器是其需要模拟完成的一组功能集合.

虚拟处理器功能可以由物理处理器和VMM共同完成.
* 对于非敏感指令！！！, 物理处理器直接解码处理其请求！！！, 并将相关效果直接反映到物理寄存器上;
* 对于敏感指令！！！, VMM负责陷入再模拟！！！, 从程序角度也就是一组数据结构与相关处理代码的集合.
    * 数据结构用于存储虚拟寄存器的内容,
    * 相关处理代码负责按照物理处理器的行为将效果反映到虚拟寄存器上.


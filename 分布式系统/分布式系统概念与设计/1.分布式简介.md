<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 分布式应用场景](#2-分布式应用场景)
    - [2.1 计算机基本功能](#21-计算机基本功能)
    - [2.1 为什么要使用分布式](#21-为什么要使用分布式)
- [3 分布式关键特性（作用）](#3-分布式关键特性作用)
    - [3.1 Scalability](#31-scalability)
        - [3.1.1 Performance（延时）](#311-performance延时)
        - [3.1.2 Availability（容错）](#312-availability容错)
    - [3.2 难点](#32-难点)
- [4 实现思路](#4-实现思路)
    - [4.1 抽象模型](#41-抽象模型)
    - [4.1 设计技术](#41-设计技术)

<!-- /TOC -->

source:
    * http://book.mixu.net/distsys/intro.html
# 1. 背景
本文从较高维度区理解分布式，主要是讨论为什么使用分布式，分布式关键特性，分布式实现思路。不谈论具体的实现方法。

# 2. 分布式应用场景
## 2.1 计算机基本功能
* 存储
* 计算

## 2.1 为什么要使用分布式
* 从技术理论上，并不一定要分布式技术。但是单机解决大数据问题成本非常高。分布式的出现主要是满足成本收益曲线。
* 单纯的提升硬件性能，并不能线性的提升计算机处理性能。事实上，当到硬件水平提升到一定程度后，性能并不会有明显提神。
    * 进程之间内存交互或者网络通信成为计算机性能线性增长的关键因素。


# 3 分布式关键特性（作用）
## 3.1 Scalability
分布式关键解决的问题是可扩展性，当系统数据量不断增大时，系统的处理性能增长率不会明显降低。

* 数据量增大，延时不会明显增大
* 多个数据中心来快速响应用户请求
* 增加节点不会增加额外的管理成本

可扩展性具体表现为非常重要的两个指标
* Performance
* Availability

### 3.1.1 Performance（延时）
高性能主要是从计算消耗的时间和资源表现。
具体表现为
* 低延时
* 高吞吐
* 少资源
### 3.1.2 Availability（容错）
高可用表现为正常访问服务时间。计算公式如下
```
Availability = uptime / (uptime + downtime)
```
高可用常用几个9指标来衡量高可用能力
90% ("one nine") 	More than a month
99% ("two nines") 	Less than 4 days
99.9% ("three nines") 	Less than 9 hours
99.99% ("four nines") 	Less than an hour
99.999% ("five nines") 	~ 5 minutes
99.9999% ("six nines") 	~ 31 seconds

## 3.2 难点
实现水平扩展关键难点如下：
* 节点增多
    * 节点增多，系统出错率线性增加（高可用难度）
    * 节点增多，系统交互增多，性能下降（高性能难度）
* 距离增加
    * 通信延时增加（高性能难度）

# 4 实现思路
## 4.1 抽象模型

* System model (asynchronous / synchronous)
* Failure model (crash-fail, partitions, Byzantine)
* Consistency model (strong, eventual)

## 4.1 设计技术
关键是两个重要的设计技术: 分割和备份

* 分割
    * 分割主要是为了并行处理，提高高性能
* 备份
    * 提高容错率
    * 访问就近节点，降低请求响应延时

<!-- TOC -->

- [1. 背景](#1-背景)
- [2. raft 概述](#2-raft-概述)
    - [2.1 核心思想](#21-核心思想)
    - [2.2 raft角色关系](#22-raft角色关系)
    - [2.3 Raft算法角色状态转化](#23-raft算法角色状态转化)
    - [2.4 term](#24-term)
- [3. leader 选举](#3-leader-选举)
- [4. 日志同步](#4-日志同步)

<!-- /TOC -->
# 1. 背景
* 最近在研究etcd分布式key-value存储，里面的一致性协议是raft。
* raft 之前一致性算法是Paxos算法，但是该算法比较复杂，实现很困难，目前大部分使用的是raft算法。
* 

# 2. raft 概述
## 2.1 核心思想
* Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制
    * 日志记录先后动作，只要有日志，状态机根据日志执行都会达到最终状态
* Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题
    * Leader选举（Leader election）
    * 日志同步（Log replication）
    * 安全性（Safety）
    * 日志压缩（Log compaction）
    * 成员变更（Membership change)
* Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）
    * Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。
    * Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。
    * Candidate：Leader选举过程中的临时角色。

## 2.2 raft角色关系
![2019-10-10-15-52-44.png](./images/2019-10-10-15-52-44.png)
* Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。
## 2.3 Raft算法角色状态转化
![2019-10-10-15-58-29.png](./images/2019-10-10-15-58-29.png)
* 如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。
* Leader在宕机之前会一直保持Leader的状态。
![2019-10-10-15-59-42.png](./images/2019-10-10-15-59-42.png)

## 2.4 term
* Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。
* 如果Leader选举失败，该term就会因为没有Leader而结束。
![2019-10-10-16-01-01.png](./images/2019-10-10-16-01-01.png)

# 3. leader 选举
* Raft 使用心跳（heartbeat）触发Leader选举。
* 当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。

* Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC (参照前面的状态机)
    * 赢得了多数的选票，成功选举为Leader；
    * 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；
    * 没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。
![2019-10-10-16-04-51.png](./images/2019-10-10-16-04-51.png)

* 选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。


# 4. 日志同步


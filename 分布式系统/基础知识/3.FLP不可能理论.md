<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 系统模型](#2-系统模型)
    - [2.1 系统假设](#21-系统假设)
    - [2.2 衡量分布式准确性的3个标准](#22-衡量分布式准确性的3个标准)
- [3. 一个sample](#3-一个sample)

<!-- /TOC -->
# 1. 背景
FLP Impossibility（FLP不可能性）是分布式领域中一个非常著名的结果，该结果在专业领域被称为“定理”，其地位之高可见一斑。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。

* FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！
因为同步通信中的一致性被证明是可以达到的，因此在之前一直有人尝试各种算法解决以异步环境的一致性问题，有个FLP的结果，这样的尝试终于有了答案。

FLP证明最难理解的是没有一个直观的sample，所有提到FLP的资料中也基本都回避了sample的要求。究其原因，sample难以设计，除非你先设计几种一致性算法，并用FLP说明这些算法都是错误的。

# 2. 系统模型
## 2.1 系统假设
任何分布式算法或定理，都尤其对系统场景的假设，这称为系统模型。FLP基于下面几点假设：
* 异步通信:与同步通信的最大区别是没有时钟、不能时间同步、不能使用超时、不能探测失败、消息可任意延迟、消息可乱序
* 通信健壮:只要进程非失败，消息虽会被无限延迟，但最终会被送达；并且消息仅会被送达一次（无重复）
* fail-stop模型:进程失败如同宕机，不再处理任何消息。相对Byzantine模型，不会产生错误消息
* 失败进程数量:最多一个进程失败

在现实中，我们都使用TCP协议（保证了消息健壮、不重复、不乱序），每个节点都有NTP时钟同步（可以使用超时），纯的异步场景相对比较少。但随着只能终端的发展，每个手机会为省电而关机，也会因为不在服务区而离线，这样的适用场景还是存在。

## 2.2 衡量分布式准确性的3个标准
* Termination（终止性）:非失败进程最终可以做出选择
* Agreement（一致性）:所有的进程必须做出相同的决议
* Validity（合法性）:进程的决议值，必须是其他进程提交的请求值

终止性，描述了算法必须在有限时间内结束，不能无限循环下去；一致性描述了我们期望的相同决议；合法性是为了排除进程初始值对自身的干扰。

# 3. 一个sample
假设有A、B、C、D、E五个进程就是否提交事务为例，每个进程都有一个随机的初始值提交（0）或回滚（1）来向其他进程发送请求，进程自己必须接收到其他进程的请求后才能根据请求内容作出本地是提交还是回滚的决定，不能仅根据自己的初始值做出决定。如果所有的进程都做出相同的决定，则认为一致性达成（Validity属性）；根据前面的系统模型，允许最多一个进程失败，因此一致性要求要放松到允许非失败进程达成一致。当然，若有两个不同的值被不同的进程选择，则认为无法达成一致。
[toc]

# 1. 背景
* 函数模板是被参数化的函数，它代表是的是一类函数。Linux Kernel经典使用宏定义（fork系统调用过程）也是实现函数参数化，但是模板支持语法检查。
```
#include "iostream"
using namespace std;

template <typename T>

T const& t_max(T const& a,T const& b){
    return a>b?a:b;
}

int main(){
    char a='0';
    char b='1';
    cout << int(::max(a,b))<<"\n";
    return 0;
}
```

# 2. 模板初级介绍
## 2.1 typename 和class
在上面的例子中，我们使用typename作为传入参数类型定义。但是class替代typename也是可以的（class 出现的比较早，但是建议使用typename，因为class有些歧义）

## 2.2 编译模板程序过程
* 模板很多地方和宏类似,宏在编译前有个宏展开。模板代码也需要展开（书中实例化，但为了避免产生歧义，这里我叫做模板展开）
s
* 可以说模板有两次编译过程
    * 模板展开之前：检查模板本身代码语法是否正确（宏展开做不到的）
    * 宏展开之后: 检查模板代码调用是否有效，比如实例化类型不支持函数调用

## 2.3 模板参数匹配
* 默认模板类型必须强制匹配
    * 比如上面调用max(4,4.2)就会出现错误

* 处理上面错误有三种方法:
    * 对实参进行强制转换，使之类型匹配max(static_cast<double>(4),4.2)  （使用float(4)这种方式进行强制转换类型也是可以的，强制转化在编译期间就能完成）
    * 显示指定（或者限定）T的类型 max<double>(4,4.2)
    * 指定两个参数可以具有不同类型
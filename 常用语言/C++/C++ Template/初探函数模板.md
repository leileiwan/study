[toc]

# 1. 背景
* 函数模板是被参数化的函数，它代表是的是一类函数。Linux Kernel经典使用宏定义（fork系统调用过程）也是实现函数参数化，但是模板支持语法检查。
```
#include "iostream"
using namespace std;

template <typename T>

T const& t_max(T const& a,T const& b){
    return a>b?a:b;
}

int main(){
    char a='0';
    char b='1';
    cout << int(::max(a,b))<<"\n";
    return 0;
}
```

# 2. 模板初级介绍
## 2.1 typename 和class
在上面的例子中，我们使用typename作为传入参数类型定义。但是class替代typename也是可以的（class 出现的比较早，但是建议使用typename，因为class有些歧义）

## 2.2 编译模板程序过程
* 模板很多地方和宏类似,宏在编译前有个宏展开。模板代码也需要展开（书中实例化，但为了避免产生歧义，这里我叫做模板展开）
s
* 可以说模板有两次编译过程
    * 模板展开之前：检查模板本身代码语法是否正确（宏展开做不到的）
    * 宏展开之后: 检查模板代码调用是否有效，比如shisdafa
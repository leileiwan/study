<!-- TOC -->

- [1. 元函数和type_traits](#1-元函数和type_traits)
    - [1.1 元函数介绍](#11-元函数介绍)
    - [1.2 类型元函数](#12-类型元函数)
        - [1.2.1 C++ 11中定义类型的元函数](#121-c-11中定义类型的元函数)
        - [1.2.2 C++14 中定义元函数](#122-c14-中定义元函数)

<!-- /TOC -->
# 1. 元函数和type_traits
## 1.1 元函数介绍
* 元函数必须是无副作用的。如果函数参数输入相同，但是函数因为某些系统变量导致函数结果不同，这样的函数是有副作用，不满足要求

* 编译期间进行的运算只能是无副作用的函数

* eg:元函数
    * constexpr表示在编译期间执行该function
```
constexpr int fun(int a){return a+1;}
```


* eg: 错误实例
    * 下面例子在编译时会出错，因为call_count是在运行时赋值的

```
static int call_count=3;
constexpr int fun2(int a){
    return a+(call_count++);
}
```
## 1.2 类型元函数
* 1.1 中类型确定是int，我们完全可以借助模板进行泛化
* 什么是函数？作者认为有输入输出就是函数，不是程序中的函数。满足函数形式又不属于程序中的函数，作就直接定义这种为元函数

### 1.2.1 C++ 11中定义类型的元函数
* 这样完全满足元函数要求，和C++ 11中定义了元函数std::enable_if一样
* 但是这种方式是使用不是很灵活
```
struct Fun_
{
    using type=T;
};
Fun_<int>::type h=3;
```
### 1.2.2 C++14 中定义元函数
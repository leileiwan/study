<!-- TOC -->

- [1. 元函数和type_traits](#1-元函数和type_traits)
    - [1.1 元函数介绍](#11-元函数介绍)
    - [1.2 类型元函数](#12-类型元函数)
        - [1.2.1 C++ 11中定义类型的元函数](#121-c-11中定义类型的元函数)
        - [1.2.2 C++14 中定义元函数](#122-c14-中定义元函数)
    - [1.3 type_traits](#13-type_traits)
    - [1.4 元函数和宏](#14-元函数和宏)
- [2 模板型模板参数与容器模板](#2-模板型模板参数与容器模板)
    - [2.1 模板作为元函数输入](#21-模板作为元函数输入)
    - [2.2](#22)

<!-- /TOC -->
# 1. 元函数和type_traits
## 1.1 元函数介绍
* 元函数必须是无副作用的。如果函数参数输入相同，但是函数因为某些系统变量导致函数结果不同，这样的函数是有副作用，不满足要求

* 编译期间进行的运算只能是无副作用的函数

* eg:元函数
    * constexpr表示在编译期间执行该function
```
constexpr int fun(int a){return a+1;}
```


* eg: 错误实例
    * 下面例子在编译时会出错，因为call_count是在运行时赋值的

```
static int call_count=3;
constexpr int fun2(int a){
    return a+(call_count++);
}
```
## 1.2 类型元函数
* 1.1 中类型确定是int，我们完全可以借助模板进行泛化
* 什么是函数？作者认为有输入输出就是函数，不是程序中的函数。满足函数形式又不属于程序中的函数，作就直接定义这种为元函数

### 1.2.1 C++ 11中定义类型的元函数
* 这样完全满足元函数要求，和C++ 11中定义了元函数std::enable_if一样
* 但是这种方式是使用不是很灵活
```
struct Fun_
{
    using type=T;
};
Fun_<int>::type h=3;
```
### 1.2.2 C++14 中定义元函数
```
struct Fun_
{
    using type=T;
};

//这里可以定义所有的类型
template<typename T>
using Fun=typename Fun_<T>::type;

Fun<int> h=3;

```

## 1.3 type_traits
* type_traits 是有boost引入的，实现功能是类型转化
* eg:
    * 下面两个都是将int&自动转化成int(根据赋值)
    * 只是形式上区别，类似前面Fun_和Fun区别
```
std::remove_reference<int&>::type h1=3;
std::remove_reference_t<int&>::type h1=3;
```

## 1.4 元函数和宏
* 宏也是一种元函数，但是C++中使用宏很少，因为宏是预处理器解析而不是编译器解析，不支持语法检查等众多特性
* 但是宏也有自身的优势，但是使用的过程中一定要小心

# 2 模板型模板参数与容器模板
## 2.1 模板作为元函数输入
* 元函数可以操作数值类型有三类：数值、类型、模板,前两种上面讲过，下面例子是模板作为参数
    * 将template <typename> class T1 作为一种参数类型就可以，class说明是类模板。上面的typename 都可以进行互换。
    * typename 可以简单理解成重新定义一种类型
    * 模板支持函数模板和类模板，但是下面模板定义的是struct，我想这时因为C++中struct和class非常接近，所以本质上还是模板类
```
template <template <typename> class T1,typename T2>
struct Fun_
{
    using type=typename T1<T2>::type;
    /* data */
};

template <template <typename> class T1,typename T2>
using Fun=typename Fun_<T1,T2>::type;

Fun<std::remove_reference,int&> h=3;
```

## 2.2 模板作为元函数输出

# 1.typedef typename 作用
* eg:
    * 虽然知道这句话大致意思，但是并不是很清楚什么时候用typename
```
typedef typename std::vector<T>::size_type size_type;
```
## 1.1 vector::size_type
明白上述语法，首先要先看清vector::size_type的意思。参考《STL源码剖析》不难发现，其实：
```
template <class T,class Alloc=alloc>
class vector{
public:
    //...
    typedef size_t size_type;
    //...
};
```
这样就看得很清晰了，vector::size_type是vector的嵌套类型定义，其实际等价于 size_t类型。
也就是说：
```
vector<int>::size_type ssize;
//就等价于
size_t ssize;
```

## 1.2 为什么使用typename关键字
```
typedef std::vector<T>::size_type size_type;//why not?
```
实际上，模板类型在实例化之前，编译器并不知道vector<T>::size_type是什么东西，事实上一共有三种可能：
```
静态数据成员
静态成员函数
嵌套类型
```
那么此时typename的作用就在此时体现出来了——定义就不再模棱两可。
typedef创建了存在类型的别名，而typename告诉编译器std::vector<T>::size_type是一个类型而不是一个成员。

# 2. using
* 经常看到using，但是分不清using在什么场合下使用，这里整理下。

## 2.1 命名空间下使用
* using namespace std;

## 2.1 在子类空间中应用基类成员
```
class T5Base {
public:
    T5Base() :value(55) {}
    virtual ~T5Base() {}
    void test1() { cout << "T5Base test1..." << endl; }
protected:
    int value;
};
 
class T5Derived : private T5Base {
public:
    //using T5Base::test1;
    //using T5Base::value;
    void test2() { cout << "value is " << value << endl; }
};
```
* 基类中成员变量value是protected，在private继承之后，对于外界这个值为private，也就是说T5Derived的对象无法使用这个value。

* 如果想要通过对象使用，需要在public下通过using T5Base::value来引用，这样T5Derived的对象就可以直接使用。

* 同样的，对于基类中的成员函数test1()，在private继承后变为private，T5Derived的对象同样无法访问，通过using T5Base::test1 就可以使用了。

 

* 注意，using只是引用，不参与形参的指定。
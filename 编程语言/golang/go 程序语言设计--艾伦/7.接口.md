<!-- TOC -->

- [1. 接口定义](#1-接口定义)
- [2. 接口定义](#2-接口定义)
    - [2.1 接口比较](#21-接口比较)

<!-- /TOC -->

# 1. 接口定义
* 只有接口暴露的方法才能被接口调用
    * 比如空接口可以被任何类型赋值，但是去无法调用被赋值的变量和方法
    ```
    var any interface{}
    any=true
    any=12.34
    ...
    ```
    *  配套的，我们需要使用类型断言来实现从空接口中还原出实际值（后面讲解）


# 2. 接口定义
从概念上，一个接口类型的值分为两部分：具体类型和该类型的值。两者称为接口的动态类型和动态值。


对于像golang这种静态语言，类型仅仅是一个编译时的概念，所以类型不是一个值。在我们的概念类型中，用来兴描述符来提供每个类型的具体信息，比如它的名字和方法。

比如，下面四个语句中，动态类型有三个值（第一个和最后一个值是一致的）
```
var w io.Writer
w =os.Stdout
w=new(bytes.Buffer)
w=nil
```

接下来让我们详细查看下在每一个语句之后w的值和相关到动态行为
* 第一个语句声明了w
    ```
    golang 所有的声明都会赋值一个0值，第一个w==nil
    ```
    ![](./images/2019-12-02-15-35-30.png)
* 第二句讲*os.File类型赋值给了w
    ```
    w=os.Stdout
    ```
    * 这次赋值讲一个具体类型隐式转化为一个接口类型，与它对应的显示转化io.writer(os.Stdout)等价
    * 接口的动态类型会设置为指针类型*os.File的类型描述符，它的动态值会设置为os.Stdout副本
    ![](./images/2019-12-02-15-40-15.png)

    * 一般来讲，编译时期我们无法知道一个接口值的动态类型会是什么，所以通过接口来做调用必然需要使用动态分支。编译器必须要生成一段代码来从类型描述符拿到名为Writed 方法地址，再间接调用该方法的地址。调用的接受者就是接口的动态值。
    * 第三句和第二句过程一致
        ![](./images/2019-12-02-15-44-04.png)


## 2.1 接口比较
接口可以使用==和!=进行比较。如果两者的动态类型完全一致并且两者的动态值相等（前提是该类型可以进行比较），那么两个接口就是相等的。可以比较的接口就可一种为map键并且可以作为switch语句的操作数。


<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 竞争](#2-竞争)
    - [2.1 竞争的定义](#21-竞争的定义)
    - [2.2 如何避免数据竞争](#22-如何避免数据竞争)
        - [2.2.1 不要修改变量](#221-不要修改变量)
        - [2.2.2 避免多个goroutine修改访问同一个变量](#222-避免多个goroutine修改访问同一个变量)
        - [2.2.3 使用互斥锁](#223-使用互斥锁)
- [3. 互斥锁 sync.Mutex](#3-互斥锁-syncmutex)

<!-- /TOC -->
# 1. 背景
本章涉及到并发机制内部，特别是多个goroutine共享变量相关问题，以及识别这些问题的分析技术，还有解决这些问题模式。

后面还会解释goroutine和操作系统线程之间区别。

# 2. 竞争
## 2.1 竞争的定义
数据库中讲解几种进程场景，通常使用银行存款为例

## 2.2 如何避免数据竞争
### 2.2.1 不要修改变量
不要在多个goroutine中修改共享变量，如果非要修改某个变量，可以尝试在修改变量之前使用初始化。
### 2.2.2 避免多个goroutine修改访问同一个变量
很多场景修改变量是必须的，我们可以使用通道技术将主goroutine设置成唯一一个能访问变量的地方，之前写的UDP心跳就是使用了大量的这种技术。

golang中强调，不要使用共享内存通信，而是通过通信来贡献内存。

* 这种技术的缺点是增加了代码的复杂度
* 优点是避免了互斥锁的使用，是代码更加优雅并且性能有一定提升
### 2.2.3 使用互斥锁
允许多个goroutine共同访问同一个变量，但是同一个时间只有一个goroutine访问共享变量，这时候可以使用互斥锁，在下一节中讲解。

# 3. 互斥锁 sync.Mutex
互斥锁应用模式非常广泛，sync包中有个专门的Mutex来专门支持互斥锁，
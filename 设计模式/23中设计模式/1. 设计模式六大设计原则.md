<!-- TOC -->

- [1. 背景](#1-背景)
- [2. 六大设计原则](#2-六大设计原则)
    - [2.1 单一职责原则](#21-单一职责原则)
        - [2.1.1  单一职责优点(类具有单一职责)](#211--单一职责优点类具有单一职责)
        - [2.1.2 单一职责原则的实现方法](#212-单一职责原则的实现方法)
    - [2.2 开闭原则(对扩展开放，对修改关闭)](#22-开闭原则对扩展开放对修改关闭)
        - [2.2.1 开闭原则的实现方法](#221-开闭原则的实现方法)
    - [2.3 里氏替换原则（继承时不重写父类方法）](#23-里氏替换原则继承时不重写父类方法)
        - [2.3.1 里氏替换原则作用](#231-里氏替换原则作用)
        - [2.3.2 里氏替换原则的实现方法](#232-里氏替换原则的实现方法)
    - [2.4 依赖倒置(使用抽象搭建架构)](#24-依赖倒置使用抽象搭建架构)
        - [2.4.1 依赖倒置原则的作用](#241-依赖倒置原则的作用)
        - [2.4.2 依赖倒置的实现方法](#242-依赖倒置的实现方法)
    - [2.5 接口隔离原则(接口依赖隔离)](#25-接口隔离原则接口依赖隔离)
        - [2.5.1 接口隔离和单一职责区别](#251-接口隔离和单一职责区别)
        - [2.5.2 接口隔离原则优点](#252-接口隔离原则优点)
        - [2.5.3 接口隔离原则的实现方法](#253-接口隔离原则的实现方法)
    - [2.6 迪米特法则（只和直接朋友交谈）](#26-迪米特法则只和直接朋友交谈)
        - [2.6.1 迪米特法则优点](#261-迪米特法则优点)
        - [2.6.2 迪米特法则缺点](#262-迪米特法则缺点)
        - [2.6.3 迪米特法则的实现方法](#263-迪米特法则的实现方法)
- [3. 六大思想关系](#3-六大思想关系)
    - [3.1 实体本身](#31-实体本身)
    - [3.2 实体之间](#32-实体之间)

<!-- /TOC -->
# 1. 背景
六大设计原则相互之间各自具有相关关系，似懂非懂

# 2. 六大设计原则
## 2.1 单一职责原则
单一职责原则（Single Responsibllity Priciple,SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且只有一个引起它变化的原因，否则类应该被拆分。

该原则提出对象不应该承担太多职责，如果一个对象承担太多职责,至少存在两个缺点：

* 1. 一个职责的变化可能会削弱或者抑制这个类实现其它职责的能力
* 2. 当一个客户端要该对象的某一个职责时，不得不将其它不需要的职责包含进来，从而造成冗余代码或者代码浪费


### 2.1.1  单一职责优点(类具有单一职责)

单一职责原则是控制类的粒度，将对象解耦，提高内聚性。

单一原则有以下优点：
* 1. 降低类复杂性
* 2. 提高类可读性
* 3. 提高系统可维护性
* 4. 降低变更引起的风险

### 2.1.2 单一职责原则的实现方法
单一职责原则简单但又是最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同类和模块中。而发现类的多重职责需要设计人员有较强的分析设计能力和相关重构经验。


## 2.2 开闭原则(对扩展开放，对修改关闭)

开闭原则（Open Close Principle）意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有代码，而是应该达到一种热插拔效果。

简而言之，为了使程序的扩展性好，易于维护和升级，需要引入接口和抽象类。


### 2.2.1 开闭原则的实现方法
可以通过"抽象约束，封装变化"实现开闭原则，即通过抽象类和接口为软件实体定义一个相对稳定的抽象，而降相同可变因素封装到相同的具体实现类中。


因为抽象灵活性好，适应性广，只要抽象合理，可以基本确保软件架构稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件发生变化时，只需要根据需求重新派生一个实现类进行扩展即可。



## 2.3 里氏替换原则（继承时不重写父类方法）
里氏提换原则主要阐述关于继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的一些道理。里氏提换原则是继承复用的基础，他反应了基类和子类自检的关系，是对开闭原则的补充，是对实现抽象化具体步骤的规范。



### 2.3.1 里氏替换原则作用
里氏替换原则主要作用如下：

* 1. 里氏替换原则氏实现开闭原则的重要方法之一
* 2. 它克服了继承中重写父类造成可用性变差的缺点

* 3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低代码出错可能性
* 4. 加强程序的健壮性，同时变更可以做到非常好的兼容性，提高程序的维护性、可扩展性、降低风险变更引入的风险

### 2.3.2 里氏替换原则的实现方法
里氏替换的原则通俗来讲就是：子类可以扩展父类功能，但不能改变父类原有功能。也就是子类继承父类时，除了添加新的方法完成增补外，j尽量不要重写父类方法。

关键原则如下：
* 1. 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
* 2. 子类可以新增自己特有方法
* 3. 当子类方法重载父类方法时，方法的前置条件（即方法的输入参数）要比父类方法更加宽松
* 4. 子类方法重载父类的方法时,方法的后置条件（方法返回值）要比父类方法更加严格

通过重写父类方法完成新的功能虽然写起来简单，但是整个继承体系的可复用性会变差。特别是运用多态比较频繁时，程序的运行出错概率会非常大。


## 2.4 依赖倒置(使用抽象搭建架构)
依赖倒置是实现开闭原则的重要基础之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象具有相对稳定性，因此以抽象搭建起来的架构要比以细节搭建起来的架构要稳定的多。

使用接口或者抽象类的目的制定好规范和契约，而不涉及具体操作，把展现细节的任务交给他们的实现类去完成。


### 2.4.1 依赖倒置原则的作用
主要有如下作用：
* 1. 依赖倒置可以降低类间的耦合性
* 2. 提高系统稳定性
* 3. 减少并行开发引起的风险
* 4. 提高代码的可读性和可维护性


### 2.4.2 依赖倒置的实现方法
依赖倒置是要通过接口编程实现类间的耦合性，实际编程中需要满足如下4点：
* 1. 每个类经量提供接口或者抽象类
* 2. 变量的声明尽量是接口或者抽象类
* 3. 任何类都不应该从具体类派生
* 4. 使用继承时经量遵循里氏替换原则



## 2.5 接口隔离原则(接口依赖隔离)
接口隔离原则（Interface Segregation Principle）要求程序员经量将臃肿庞大的接口拆分成更小和更具体的接口，让接口中只包含客户感兴趣的方法。


### 2.5.1 接口隔离和单一职责区别
接口隔离原则和单一职责都是为了提高类的内聚性，降低他们之间的耦合性，提现了封装的思想，但是两者是不同的：
* 单一职责原则注重的是职责，而接口隔离原则注重的是接口依赖的隔离
* 单一职责原则主要是约束类，他针对程序中实现和细节；接口隔离原则主要约束接口，主要针对抽象程序和程序整体框架构建


### 2.5.2 接口隔离原则优点
接口隔离原则是为了约束接口、降低类对接口的依赖性，有以下5个优点：
* 1. 将庞大接口拆分，可以预防外来变更扩散，提高灵活性和维护性
* 2. 提高系统内聚性，减少对外交互，降低系统耦合性
* 3. 如果接口粒度定制合理，能够保证系统稳定；但是如果接口粒度太小，会使得系统复杂化；如果粒度太大，灵活性降低、无法提供定制服务、给整体项目带来无法预料风险
* 4. 使用多个专门接口还能提现对象层次，因为可以通过接口继承，实现总接口定义
* 5. 减少项目工程中的冗余代码。过大接口通常置放很多不同方法，当实现这个接口时被迫实现冗余代码。


### 2.5.3 接口隔离原则的实现方法
具体实现接口隔离原则时，尽量根据以下规则衡量：
* 1. 接口尽量小，但是要有限度。一个接口只服务于一个模块或者业务。
* 2. 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法
* 3. 谅解环境，拒绝盲从。每个项目或者产品都有选定的环境因素，环境不同，接口拆分标准就不同深入了解业务逻辑
* 4. 提高类聚，减少对外交互。使接口用最少方法完成最多事情


## 2.6 迪米特法则（只和直接朋友交谈）
迪米特法则（Law of Demeter）定义是：只与你直接朋友交谈，不跟陌生人说话。也就是两个软件实体无需直接通信，那就不应该发生直接调用，可以通过第三方转发调用。其目的是降低类之间耦合度，提高模块之间的相对独立性。

迪米特法则中的朋友是指： 当前对象的成员对象、当前对象所创建的对象、当前对象方法参数等。这些对象同当前对象存在关联、聚合、组合关系，可以直接访问这些对象方法。


### 2.6.1 迪米特法则优点
迪米特法则要求限制软件实体之间的通信宽度和深度，正确使用迪米特法则将有以下两个优点。
* 1. 降低了类之间的耦合度，提高模块之间的相对独立性
* 2. 由于亲和度降低，从而提高了类的可复用率和系统扩展性

### 2.6.2 迪米特法则缺点

过度使用迪米特法则会产生大量的中介类，从而增加系统复杂性，使得模块之间的通信效率降低。

### 2.6.3 迪米特法则的实现方法
从迪米特法则的定义和特点可知，强调如下两点：
* 1. 从依赖者角度来说，只依赖该依赖对象
* 2. 从被依赖的角度来说，只暴露该暴露方法

所以迪米特法则注意以下6点：
* 1. 在类的划分上，应该创建类的耦合类。类之间的耦合越弱，越有利于实现可复用目标
* 2. 在类的结构设计上，尽量降低类成员的访问权限
* 3. 在类的设计上，优先将一个类设计成不变类
* 4. 不暴露类的属性成员，而应该提供相应的访问器（set、get）
* 5. 谨慎使用序列化功能


# 3. 六大思想关系
## 3.1 实体本身
* 单一职责：约束类单一职责
* 接口隔离：约束接口隔离

## 3.2 实体之间
* 开闭原则：软件扩展时，对扩展开放，对修改关闭
    * 里氏替换原则：只能不能修改父类方法，是开闭原则实现重要方法
    * 依赖导致：模块之前依赖抽象，不依赖实体类，是开闭原则重要方法
* 迪米特法则：实体只和直接朋友交互